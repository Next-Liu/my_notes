#### 为什么使用B+树做索引

与B+ 树相比，平衡二叉树、红黑树在同等数据量下，**高度更高，性能更差**，而且它们会频繁执行再平衡过程，来保证树形结构平衡

与B+ 树相比，跳表在极端情况下会退化为链表，**平衡性差**，而数据库查询需要一个可预期的查询时间，并且跳表需要更多的内存。

与B+ 树相比，B 树的数据存储在全部节点中，**对范围查询不友好。**非叶子节点存储了数据，**导致内存中难以放下全部非叶子节点**。如果内存放不下非叶子节点，那么就意味着查询非叶子节点的时候都需要磁盘 IO。

#### 主键索引

- 主键索引是针对表中的主键列建立的索引。
- 主键是表中用于唯一标识每一行的列。主键索引确保主键列中的值是唯一的，并且通常自动为主键列创建索引。
- 主键索引可以加速对表中特定行的查找和连接操作，因为数据库引擎会使用主键索引来快速定位数据行。
- 主键索引允许将 NULL 值插入主键列（如果主键列允许为空），但在索引中只存储非空值。

#### 覆盖索引

如果你查询的列全部都在某个索引里面，那么数据库可以直接把索引存储的这些列的值给你，而不必回表。

#### 聚簇索引和非聚簇索引

聚簇索引是对表中的数据行进行物理排序，并且索引的键值就是表中的主键或者唯一约束。

如果索引叶子节点存储的是数据行，那么它就是聚簇索引，否则就是非聚簇索引。

简单来说，某个数据表本身你就可以看作是一棵使用主键搭建起来 B+ 树，这棵树的叶子节点放着表的所有行。而其他索引也是 B+ 树，不同的是它们的**叶子节点存放的是主键。**      

####  聚簇索引和主键索引的区别

- 主键索引通常用于快速定位和唯一标识表中的特定行，而聚簇索引可以加速范围查询和特定值查询，因为它们按顺序存储数据行。
- 一个表只能有一个聚簇索引，通常与主键索引相关联，但可以有多个非聚簇索引（例如，唯一索引、复合索引等）     

#### 组合索引

​	组合索引（Compound Index）是指由多个列所组合而成的 B+树索引，之前是对一个列排序，现在是对多个列排序。

1. 覆盖多个查询条件，如（a，b）索引可以覆盖查询 a = ? 或者 a = ? and b = ?；
2. 避免 SQL 的额外排序，提升 SQL 性能，如 WHERE a = ? ORDER BY b 这样的查询条件；

#### 组合索引的执行流程

- **索引生效**：查询条件匹配了组合索引的最左前缀 `(last_name, first_name)`。
- **执行流程**：
  1. 在索引中查找 `last_name = 'Smith'`。
  2. 在匹配的 `last_name` 中进一步查找 `first_name = 'John'`。
  3. 返回匹配的行。

#### 假设有组合索引（a,b,c）,查询条件是a=10 AND b>20 AND c=10，为什么b列可以使用索引而c列不能使用，具体原因是什么

假设表数据如下：

| a    | b    | c    |
| :--- | :--- | :--- |
| 10   | 15   | 5    |
| 10   | 20   | 10   |
| 10   | 25   | 15   |
| 10   | 30   | 10   |
| 20   | 10   | 5    |
| 20   | 20   | 10   |

首先根据a=10定位数据：

​	定位到 `a=10` 的叶子节点范围：`[(10, 15, 5), (10, 20, 10), (10, 25, 15), (10, 30, 10)]`。

根据b>20过滤数据（因为在 `a=10` 的基础上，`b` 列的值是有序的）：

​	找到符合条件的记录：`[(10, 25, 15), (10, 30, 10)]`。（此时打破了c列的有序性）

无法使用c=10过滤数据：

​	在 B+ 树中，范围条件之后的列（即 `c` 列）无法被直接使用，因为索引是按照 `(a, b, c)` 的顺序存储的，`b` 列的范围条件使得 `c` 列的值不再有序。

​	**数据库只能扫描 `b>20` 的所有记录，然后逐条检查 `c=10` 的条件。**

#### 没有索引和有索引的执行流程

没有索引时，数据库只能通过 **全表扫描（Full Table Scan）** 的方式来查找数据。

#### 索引失效

- 当我们使用左或者左右模糊匹配的时候，也就是 `like %xx` 或者 `like %xx%`这两种方式都会造成索引失效；
- 当我们在查询条件中对索引列使用函数，就会导致索引失效。
- 当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。
- MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。
- 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。
- 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。

