#### 为什么使用B+树做索引

与B+ 树相比，平衡二叉树、红黑树在同等数据量下，**高度更高，性能更差**，而且它们会频繁执行再平衡过程，来保证树形结构平衡

与B+ 树相比，跳表在极端情况下会退化为链表，**平衡性差**，而数据库查询需要一个可预期的查询时间，并且跳表需要更多的内存。

与B+ 树相比，B 树的数据存储在全部节点中，**对范围查询不友好。**非叶子节点存储了数据，**导致内存中难以放下全部非叶子节点**。如果内存放不下非叶子节点，那么就意味着查询非叶子节点的时候都需要磁盘 IO。

#### B+树的特性是什么

**所有叶子节点都在同一层：**这是B+树的一个重要特性，确保了所有数据项的检索都具有相同的I/O延迟，提高了搜索效率。每个叶子节点都包含指向相邻叶子节点的指针，形成一个链表，由于叶子节点之间的链接，B+树非常适合进行范围查询和排序扫描。可以沿着叶子节点的链表顺序访问数据，而无需进行多次随机访问。 **非叶子节点存储键值：**非叶子节点仅存储键值和指向子节点的指针，不包含数据记录。这些键值用于指导搜索路径，帮助快速定位到正确的叶子节点。并且，由于非叶子节点只存放键值，当数据量比较大时，相对于B树，B+树的层高更少，查找效率也就更高。 

**叶子节点存储数据记录：**与B树不同，B+树的叶子节点存储实际的数据记录或指向数据记录的指针。这意味着每次搜索都会到达叶子节点，才能找到所需数据。

自平衡：B 树在插入、删除和更新操作后会自动重新平衡，确保树的高度保持相对稳定，从而保持良好的搜索性能。每个节点最多可以有M个子节点，最少可以有ceil(M/2)个子节点（除了根节点），这里的M是树的阶数。

### 查询数据时，到了B+树的叶子节点，之后的查找数据是如何做？

​	页目录创建的过程如下： 

​	将所有的记录划分成**几个组**，**这些记录包括最小记录和最大记录**，但不包括标记为“已删除”的记录； 

​	每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段（上图中粉红色字段） 	页目录用来存储**每组最后一条记录的地址偏移量**，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），每个槽相当于指针指向了不同组的最后一个记录。

**页目录就是由多个槽组成的**，槽相当于分组记录的索引。然后，因为记录是按照「主键值」从小到大排序的，所以我们通过槽查找记录时，可以使用**二分法**快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录，无需从最小记录开始遍历整个页中的记录链表。以上面那张图举个例子，5 个槽的编号分别为 0，1，2，3，4，我想查找主键为 11 的用户记录： 先二分得出槽中间位是 (0+4)/2=2 ，2号槽里最大的记录为 8。因为 11 > 8，所以需要从 2 号槽后继续搜索记录； 再使用二分搜索出 2 号和 4 槽的中间位是 (2+4)/2= 3，3 号槽里最大的记录为 12。因为 11 < 12，所以主键为 11 的记录在 3 号槽里； 再从 3 号槽指向的主键值为 9 记录开始向下搜索 2 次，定位到主键为 11 的记录，取出该条记录的信息即为我们想要查找的内容。

#### 主键索引

- 主键索引是针对表中的主键列建立的索引。
- 主键是表中用于唯一标识每一行的列。主键索引确保主键列中的值是唯一的，并且通常自动为主键列创建索引。
- 主键索引可以加速对表中特定行的查找和连接操作，因为数据库引擎会使用主键索引来快速定位数据行。
- 主键索引允许将 NULL 值插入主键列（如果主键列允许为空），但在索引中只存储非空值。

#### 覆盖索引

如果你查询的列全部都在某个索引里面，那么数据库可以直接把索引存储的这些列的值给你，而不必回表。

#### 聚簇索引和非聚簇索引

聚簇索引是对表中的数据行进行物理排序，并且索引的键值就是表中的主键或者唯一约束。

如果索引叶子节点存储的是数据行，那么它就是聚簇索引，否则就是非聚簇索引。

简单来说，某个数据表本身你就可以看作是一棵使用主键搭建起来 B+ 树，这棵树的叶子节点放着表的所有行。而其他索引也是 B+ 树，不同的是它们的**叶子节点存放的是主键。**      

####  聚簇索引和主键索引的区别

- 主键索引通常用于快速定位和唯一标识表中的特定行，而聚簇索引可以加速范围查询和特定值查询，因为它们按顺序存储数据行。
- 一个表只能有一个聚簇索引，通常与主键索引相关联，但可以有多个非聚簇索引（例如，唯一索引、复合索引等）     

#### 二级索引

一张表只能有一个聚簇索引，二级索引是基于表中的其他列（非主键列）构建的。叶子结点存放的是主键值

#### 组合索引

​	组合索引（Compound Index）是指由多个列所组合而成的 B+树索引，之前是对一个列排序，现在是对多个列排序。

1. 覆盖多个查询条件，如（a，b）索引可以覆盖查询 a = ? 或者 a = ? and b = ?；
2. 避免 SQL 的额外排序，提升 SQL 性能，如 WHERE a = ? ORDER BY b 这样的查询条件；

![](D:\学习笔记\MySQL\picture\Snipaste_2025-03-17_01-21-42.png)

#### 组合索引失效的原因

- where b=2；
- where c=3；
- where b=2 and c=3；

​       这些查询条件之所以会失效，是因为(a, b, c) 联合索引，是先按 a 排序，在 a 相同的情况再按 b 排序，在 b 相同的情况再按 c 排序。所以，**b 和 c 是全局无序，局部相对有序的**，这样在没有遵循最左匹配原则的情况下，是无法利用到索引的。

![](D:\学习笔记\MySQL\picture\Snipaste_2025-03-17_01-25-14.png)

只有在a相同时，b才是有序的

#### 组合索引的执行流程

- **索引生效**：查询条件匹配了组合索引的最左前缀 `(last_name, first_name)`。
- **执行流程**：
  1. 在索引中查找 `last_name = 'Smith'`。
  2. 在匹配的 `last_name` 中进一步查找 `first_name = 'John'`。
  3. 返回匹配的行。

#### 假设有组合索引（a,b,c）,查询条件是a=10 AND b>20 AND c=10，为什么b列可以使用索引而c列不能使用，具体原因是什么

假设表数据如下：

| a    | b    | c    |
| :--- | :--- | :--- |
| 10   | 15   | 5    |
| 10   | 20   | 10   |
| 10   | 25   | 15   |
| 10   | 30   | 10   |
| 20   | 10   | 5    |
| 20   | 20   | 10   |

首先根据a=10定位数据：

​	定位到 `a=10` 的叶子节点范围：`[(10, 15, 5), (10, 20, 10), (10, 25, 15), (10, 30, 10)]`。

根据b>20过滤数据（因为在 `a=10` 的基础上，`b` 列的值是有序的）：

​	找到符合条件的记录：`[(10, 25, 15), (10, 30, 10)]`。（此时打破了c列的有序性）

无法使用c=10过滤数据：

​	在 B+ 树中，范围条件之后的列（即 `c` 列）无法被直接使用，因为索引是按照 `(a, b, c)` 的顺序存储的，`b` 列的范围条件使得 `c` 列的值不再有序。

​	**数据库只能扫描 `b>20` 的所有记录，然后逐条检查 `c=10` 的条件。**

#### 没有索引和有索引的执行流程

没有索引时，数据库只能通过 **全表扫描（Full Table Scan）** 的方式来查找数据。

#### 索引失效

- 当我们使用左或者左右模糊匹配的时候，也就是 `like %xx` 或者 `like %xx%`这两种方式都会造成索引失效；
- 当我们在查询条件中对索引列使用函数，就会导致索引失效。
- 当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。
- MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。
- 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。
- 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。

#### MySQL的索引是如何实现的

​	B+Tree 是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引，而且每个节点里的数据是按主键顺序存放的。每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息，并且每一个叶子节点都有两个指针，分别指向下一个叶子节点和上一个叶子节点，形成一个双向链表。

![](D:\学习笔记\MySQL\picture\Snipaste_2025-03-17_00-54-26.png)

​	这条语句使用了主键索引查询 id 号为 5 的商品。查询过程是这样的，B+Tree 会自顶向下逐层进行查找：将 5 与根节点的索引数据 (1，10，20) 比较，5 在 1 和 10 之间，所以根据 B+Tree的搜索逻辑，找到第二层的索引数据 (1，4，7)；在第二层的索引数据 (1，4，7)中进行查找，因为 5 在 4 和 7 之间，所以找到第三层的索引数据（4，5，6）；在叶子节点的索引数据（4，5，6）中进行查找，然后我们找到了索引值为 5 的行数据。**数据库的索引和数据都是存储在硬盘的，我们可以把读取一个节点当作一次磁盘 I/O 操作。那么上面的整个查询过程一共经历了 3 个节点，也就是进行了 3 次 I/O 操作。B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I/O，所以B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4次。**

