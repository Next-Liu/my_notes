## 1.如何分析MySQL的慢查询

通过EXPLAIN命令，主要关注其中的type字段、key（索引）字段、Extra字段

type表明查询执行的类型，描述了查询是如何执行的

- **system**：如果表使用的引擎对于表行数统计是精确的（如：MyISAM），且**表中只有一行记录**的情况下，访问方法是 system ，是 const 的一种特例。
- **range**：对索引列进行范围查询，执行计划中的 key 列表示哪个索引被使用了。

- **index**：查询遍历了整棵索引树，与 ALL 类似，只不过扫描的是索引，而索引一般在内存中，速度更快。
- **ALL**：全表扫描

key代表查询使用到的索引列，NULL表明没有用到

Extra表明MySQL查询的额外信息

- **Using index**：表明查询使用了覆盖索引，不用回表，查询效率非常高。
- **Using where**：表明查询使用了 WHERE 子句进行条件过滤。一般在没有使用到索引的时候会出现。

​	

**分析查询语句：**使用EXPLAIN命令分析SQL执行计划，找出慢查询的原因，比如是否使用了全表扫描，是否存在索引未被利用的情况等，并根据相应情况对索引进行适当修改。

**创建或优化索引：**根据查询条件创建合适的索引，特别是经常用于WHERE子句的字段、Orderby 排序的字段、Join 连表查询的字典、 group by的字段，并且如果查询中经常涉及多个字段，考虑创建联合索引，使用联合索引要符合最左匹配原则，不然会索引失效

**避免索引失效：**比如不要用左模糊匹配、函数计算、表达式计算等等。 

查询优化：避免使用SELECT *，只查询真正需要的列；使用覆盖索引，即索引包含所有查询的字段；联表查询最好要以小表驱动大表，并且被驱动表的字段要有索引，当然最好通过冗余字段的设计，避免联表查询。 

**分页优化：**针对 limit n,y 深分页的查询优化，可以把Limit查询转换成某个位置的查询：select * from tb_sku where id>20000 limit 10，该方案适用于主键自增的表，

**优化数据库表：**如果单表的数据超过了千万级别，考虑是否需要将大表拆分为小表，减轻单个表的查询压力。也可以将字段多的表分解成多个表，有些字段使用频率高，有些低，数据量大时，会由于使用频率低的存在而变慢，可以考虑分开。

**使用缓存技术：**引入缓存层，如Redis，存储热点数据和频繁查询的结果，但是要考虑缓存一致性的问题，对于读请求会选择旁路缓存策略，对于写请求会选择先更新 db，再删除缓存的策略。