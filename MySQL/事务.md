#### 1.四大特性

原子性

隔离性：一个事务的执行不能被其他事务干扰，即一个事务内部操作以及使用的数据对并发的其他事务事隔离的，并发执行的各个事务之间不能相互干扰

持久性：事务一旦提交，对数据库的改变就是持久的

一致性：数据从一个合法性状态变换到另一个合法性状态，合法的状态是自己预先设定的

#### 2.显式事务 隐式事务

显示事务：

```mysql
start transaction read only/read write(默认)/with consistent snapshot(开启一致性读)
一系列DML操作
commit/rollback
savepoint 保存点名称
rollback to savepoint
```

隐式事务：

```mysql
set autocommit=false 默认是 on
为on的时候一条DML语句是一个独立的事务，如果使用start transaction 即使是on,DML语句也不会自动提交
```

#### 3.事务并发引起的问题

事务并发可能会引发以下几种常见的问题：

1. **丢失更新（Lost Updates）**：当两个或多个事务同时尝试更新同一数据时，最后一个提交的事务可能会覆盖先前提交的事务所做的更改，导致部分更新丢失。
2. **脏读（Dirty Reads）**：一个事务读取了另一个事务尚未提交的数据。如果另一个事务在稍后回滚，则读取的数据可能是无效或不一致的。
3. **不可重复读（Non-Repeatable Reads）**：一个事务在读取同一数据两次之间，另一个事务修改了该数据，导致第一个事务读取到了不同的值，这可能导致一致性问题。
4. **幻读（Phantom Reads）**：一个事务在读取一系列数据行时，另一个事务插入了新的数据行，导致第一个事务再次读取相同的范围时发现了新增的“幻影”行，这可能导致一致性问题。

#### 4.事务的隔离级别

串行化>可重复读>读已提交>读未提交

- **读未提交（read uncommitted）**，指一个事务还没提交时，它做的变更就能被其他事务看到；

- **读提交（read committed）**，指一个事务提交之后，它做的变更才能被其他事务看到；

- **可重复读（repeatable read）**，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，**MySQL InnoDB 引擎的默认隔离级别**；

- ### 为什么可重复读不能解决幻读

  “可重复读”隔离级别的实现通常是通过锁定已经读取的行来实现的。这种锁定可以防止其他事务**修改**这些行，但无法防止其他事务**插入或删除满足查询条件的新行或旧行**。这意味着在一个事务期间，其他事务仍然可以对查询范围内的行进行插入或删除操作，从而导致幻读。

  事务A查询age=20的名字

  事务B加入age=20的条目

- **串行化（serializable ）**；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；

- ![](D:\学习笔记\MySQL\picture\Snipaste_2024-02-08_03-02-52.png)

## 5.mvcc是什么，解决了什么问题

**MVCC的目的主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁。**

​	MVCC (Multi-version Concurency Control，**多版本并发控制**)是一种并发控制机制，允许多个事务同时读取和写入数据库，而无需互相等待，从而提高数据库的并发性能。在 MVCC中，数据库为每个事务创建一个数据快照，每当数据被修改时，MYSQL不会立即覆盖原有数据，而是生成新版本的记录，每个记录都保留了对应的版本号或时间戳,多版本之间串联起来就形成了一条版本链，这样不同时刻启动的事务可以无锁地获得不同版本的数据(普通读)。此时读(普通读)写操作不会阻塞。写操作可以继续写，无非就是会创建新的数据版本(但只有在事务提交后，新版本才会对其他事务可见。未提交的事务修改不会影响其他事务的读取，历史版本记录可供已经启动的事务读取。

​	MVCC 是 MySQL InnoDB 引擎用于控制数据并发访问的协议。MVCC 主要是借助于版本链来实现的。在 InnoDB 引擎里面，每一行都有两个额外的列，一个是 trx_id，代表的是修改这一行数据的事务 ID。另外一个是 roll_ptr，代表的是回滚指针。InnoDB 引擎通过回滚指针，将数据的不同版本串联在一起，也就是版本链。这些串联起来的历史版本，被放到了 undolog 里面。当某一个事务发起查询的时候，MVCC 会根据事务的隔离级别来生成不同的 Read View，从而控制事务查询最终得到的结果。

​	主要解决读写并发的问题，只用锁效率太低

### 隐藏列

DB_TRX_ID:当前这条数据被哪个事务id维护

DB_ROLL_PTR:指向最新的历史数据

### **版本链**

历史数据存储在undolog，多事务并发时都存储在undolog中

在MVCC中，对于每次更新操作，旧值会被保存到一条undo日志中，即使它是该记录的旧版本。随着更新次数的增加，所有的版本都会通过roll_pointer属性连接成一个链表，称之为版本链。

版本链的头节点代表当前记录的最新值。此外，每个版本还包含生成该版本的事务ID。

### **ReadView**

**一致性视图，全称 Read View ，是用来判断版本链中的哪个版本对当前事务是可见的**

具体如何找历史数据，就使用到了ReadView，每一次查询都会创建一个ReadView，主要存储当前事务id，未提交事务id（从小到大），未开始事务id

具体匹配规则如下（以读已提交为例（**每次查询**都会创建一个ReadView））：

1.拿到undolog最新版本的数据，**根据这个事务id和当前事务id进行对比 ，若相等，说明可以读取**，**若小于未提交事务的最小id，可以读取**，**若大于未开始事务id，不能读取**，**若在未提交事务id范围内，不能读取**

2.若都不满足，则通过roll指针找历史版本的数据再进行上述判断

**可重复读**（执行多次同样查询时，只会创建一次ReadView）

串行化利用的是表锁

#### 6.MySQL解决幻读

- 针对**快照读**（普通 select 语句），是读取一个一致性视图中的数据，反应事务开始时数据库的快照，可能是历史版本**（通过 MVCC 方式解决了幻读）**，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。（即只能看到已经提交的事务的数据）

  **MVCC主要就是为了实现读-写冲突不加锁，而这个读指的就是快照读，是乐观锁的实现。**

- 针对**当前读**（select ... for update 等语句），是**通过 next-key lock（记录锁+间隙锁）方式解决了幻读**，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。

  next-key lock可以解决删除操作而引发的幻读问题：

  

  ### 间隙锁

  1. **范围查询**：

     - 当使用范围查询（如 `BETWEEN`、`>`、`<`）时，数据库可能会使用间隙锁来锁定查询范围内的间隙。

     - 例如：

       ```
       SELECT * FROM users WHERE age BETWEEN 20 AND 30 FOR UPDATE;
       ```

       这条语句可能会锁定 `age` 在 20 到 30 之间的所有间隙，防止其他事务插入 `age` 为 21 到 29 的记录。

  ​    **2.锁定间隙：**

  - | id   | age  |
    | :--- | :--- |
    | 1    | 10   |
    | 3    | 20   |
    | 5    | 30   |

    ```
    SELECT * FROM users WHERE age = 20 FOR UPDATE;
    ```

    数据库会锁定 `age = 20` 的行，同时锁定其前后的间隙：

    - 锁定 `(10, 20)` 和 `(20, 30)` 的间隙，防止其他事务插入 `age` 为 11 到 19 或 21 到 29 的记录。

  **如果 update 语句的 where 条件没有用到索引列，那么就会全表扫描**

  **锁是在遍历索引的时候加上的，并不是针对输出的结果加锁**。所以在全表扫描的时候，会对整张表加锁，使得其他事务无法对表进行增删改查，如果走的是某个字段的索引，就不会锁住整张表，会锁住某个范围