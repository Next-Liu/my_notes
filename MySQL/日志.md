#### undo log、redo log、bin log的作用

​	undo log： 一种用于撤销回退的日志。在事务没提交之前，MySQL 会先记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以利用 undo log 来进行回滚

​	redo log：是 Innodb 存储引擎层生成的日志，实现了事务中的**持久性**，主要**用于掉电等故障恢复**；

### 有了undolog为啥还需要redolog呢？

Buffer Pool 是提高了读写效率没错，但是问题来了，Buffer Pool 是基于内存的，而内存总是不可靠，万一断电重启，还没来得及落盘的脏页数据就会丢失。

为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候，**InnoDB 引擎就会先更新内存（同时标记为脏页）**，然后将本次对这个页的修改以 redo log 的形式记录下来，这个时候更新就算完成了。 后续，InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 WAL （Write-Ahead Logging）技术。 WAL 技术指的是， **MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上。**

redo log 是物理日志，记录了某个数据页做了什么修改，比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新，每当执行一个事务就会产生这样的一条或者多条物理日志。 **在事务提交时，只要先将 redo log 持久化到磁盘即可**，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。 当系统崩溃时，虽然脏页数据没有持久化，但是 redo log 已经持久化，接着 **MySQL 重启后，可以根据 redo log 的内容，将所有数据恢复到最新的状态。**

redo log 记录了此次事务「完成后」的数据状态，记录的是更新之后的值； 

undo log 记录了此次事务「开始前」的数据状态，记录的是更新之前的值；

事务提交之前发生了崩溃，重启后会通过 undo log 回滚事务，事务提交之后发生了崩溃，重启后会通过 redo log 恢复事务



![](D:\学习笔记\MySQL\picture\Snipaste_2025-03-17_01-57-58.png)

**WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上**。

​	redo log记录了某个数据页做了什么修改，在事务提交时，只要先将 redo log 持久化到磁盘即可，**redo log 保证了事务四大特性中的持久性**。

​	注意： redo log 不是直接写入磁盘，redo log 也有自己的缓存—— **redo log buffer**，每当产生一条 redo log 时，会先写入到 redo log buffer。

​	binlog 文件是记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作，比如 SELECT 和 SHOW 操作。

### bin log

二进制日志，数据备份和主从复制

用于记录所有对数据库执行的**写操作**（如`INSERT`、`UPDATE`、`DELETE`等），但不记录`SELECT`操作。`binlog`的主要作用是：

1. **数据恢复**：通过`binlog`可以恢复数据库到某个时间点的状态。
2. **主从复制**：`binlog`是实现MySQL主从复制的核心，主库将`binlog`发送给从库，从库重放这些日志以实现数据同步。
3. **审计**：可以通过`binlog`追踪数据库的变更历史。

#### redo log 和 binlog 有什么区别？

1、适用对象不同：

- binlog 是 MySQL 的 **Server** 层实现的日志，所有存储引擎都可以使用；
- redo log 是 Innodb 存储引擎实现的日志；

2、文件格式不同：

- binlog 有 3 种格式类型，分别是 STATEMENT（默认格式）、ROW、 MIXED，区别如下：
  - STATEMENT：每一条修改数据的 SQL 都会被记录到 binlog 中（相当于记录了逻辑操作，所以针对这种格式， binlog 可以称为逻辑日志），主从复制中 slave 端再根据 SQL 语句重现。但 STATEMENT 有动态函数的问题，比如你用了 uuid 或者 now 这些函数，你在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致；
  - ROW：记录行数据最终被修改成什么样了（这种格式的日志，就不能称为逻辑日志了），不会出现 STATEMENT 下动态函数的问题。但 ROW 的缺点是每行数据的变化结果都会被记录，比如执行批量 update 语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大，而在 STATEMENT 格式下只会记录一个 update 语句而已；
  - MIXED：包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式；
- redo log 是物理日志，记录的是在某个数据页做了什么修改，比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新；

3、写入方式不同：

- bin log 是**追加写**，写满一个文件，**就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。**
- redo log **是循环写，日志空间大小是固定，全部写满就从头开始，保存未被刷入磁盘的脏页日志。**

4、用途不同：

- bin log 用于备份恢复、主从复制；
- redo log 用于掉电等故障恢复。

#### 两阶段提交的过程以及原因

在分布式数据库中，一个事务可能涉及多个数据库节点（如主从复制、分库分表等）。为了确保这些节点上的操作要么全部提交，要么全部回滚

事务提交后，redo log 和 binlog 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态，这样就造成两份日志之间的逻辑不一致。

![](D:\学习笔记\MySQL\picture\Snipaste_2025-03-12_23-18-29.png)

两阶段提交把事务的提交拆分成了2个阶段，分别是**准备阶段和提交阶段**。

**准备阶段**：

- 将 XID（内部 XA 事务的 ID）写入到 Redo Log。
- 将 Redo Log 对应的事务状态设置为 prepare 阶段，然后将 Redo Log 持久化到磁盘（受 `innodb_flush_log_at_trx_commit` 参数控制）

**提交阶段**：

​	将 XID 写入到 Binlog
​	将 Binlog 持久化到磁盘中（受 sync_binlog 参数控制）
​	调用引擎的提交接口，将 Redo Log 设置为 commit 状态，此时该状态并需要持久化到磁盘中，只需 write 到 OS 的 page cache 中即可，因为只要 Binlog 刷盘成功，Redo Log 的即使是 prepare 状态也无所谓，一样会被认为事务执行成功。

在两阶段提交中，是以 **binlog 刷入磁盘时机作为事务提交成功的标志的:**

![](D:\学习笔记\场景题\pictures\Snipaste_2025-03-18_15-06-09.png)

### **崩溃恢复**

如果 MySQL 在事务提交过程中崩溃，重启时会通过 Redo Log 和 Binlog 进行恢复：

1. **检查 Redo Log**：
   - 如果 Redo Log 中有标记为 **Prepare** 的事务，说明事务尚未提交。
2. **检查 Binlog**：
   - 如果 Binlog 中存在对应的事务记录，说明事务已经成功写入 Binlog，可以提交。
   - 如果 Binlog 中不存在对应的事务记录，说明事务未写入 Binlog，需要回滚。
3. **提交或回滚**：
   - 如果事务在 Binlog 中存在，MySQL 会将 Redo Log 中的事务标记为 **Commit**，完成事务提交。
   - 如果事务在 Binlog 中不存在，MySQL 会回滚事务，撤销所有修改。