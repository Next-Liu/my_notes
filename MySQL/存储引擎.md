show engines;

show variables like "%storage_engine%"; 查看使用的存储引擎

SHOW VARIABLES LIKE 'datadir'; MySQL 数据库的文件存放的目录

每创建一个database，在/var/lib/mysql目录下创建一个以database命名的目录



存储引擎功能：接收上层传下来的指令，然后对表中的数据进行提取或者写入操作

在创建表的时候也可以指定引擎

```sql
CREATE TABLE TABLE_NAME() engine=
```

db.opt，用来存储当前数据库的默认字符集和字符校验规则。

#### InnoDB引擎        

​	具备外键支持功能的事务存储引擎、支持事务的提交和回滚、维护成本低，崩溃恢复时自动将之前提交的事务定型，撤销没有提交的进程

​	有大量**更新和删除操作推荐使用、适合高并发**

表名.frm文件存储表结构

表名.ibd存储数据和索引

​	写的效率低，对内存要求高(缓存索引和数据，MyISAM只用缓存索引)

#### MyISAM引擎

​	非事务处理存储引擎，小数据量的表

​	崩溃后无法安全恢复(不支持事务)

表名.frm存储表结构

表名.myd存储数据

表名.myi存储索引

![](D:\学习笔记\MySQL\picture\Snipaste_2024-02-01_03-40-05.png)





#### 表空间结构

![](D:\学习笔记\MySQL\picture\Snipaste_2024-02-01_17-20-04.png)

**InnoDB 的数据**是按页为单位进行读写，每个页默认大小为16KB

​	在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了。

​	表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。

- 索引段：存放 B + 树的非叶子节点的区的集合；
- 数据段：存放 B + 树的叶子节点的区的集合；
- 回滚段：存放的是回滚数据的区的集合，之前讲[事务隔离 (opens new window)](https://xiaolincoding.com/mysql/transaction/mvcc.html)的时候就介绍到了 MVCC 利用了回滚段实现了多版本查询数据。



#### InnoDB的行格式

Redundant(没人用)、Compact、Dynamic和 Compressed 	



#### char和varchar区别

varchar需要1或者2个字节存储字符串长度，<=255字节用1个字节，但会导致行变成变长的，如果在更新时一个行变的比原来更长，页中没有额外空间，使用MyISAM会将行拆成不同的片段存储，InnoDB则会分裂页使行放在页内。字符串列的最大长度比平均长度长很多、更新少适合

char类型会删除字符串的末尾空格，适合存储短的字符串或者所有值接近一个长度，比如密码的MD5值，并且也不容易产生碎片

#### 聚簇索引和二级索引

聚簇索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚簇索引的叶子节点；

二级索引的叶子节点存放的是主键值，而不是实际数据。

  	一张表只能有一个聚簇索引，那为了实现非主键字段的快速搜索，就引出了二级索引（非聚簇索引/辅助索引），它也是利用了 B+ 树的数据结构，但是二级索引的叶子节点存放的是主键值，不是实际数据。

InnoDB 在创建聚簇索引时，会根据不同的场景选择不同的列作为索引：

- 如果有主键，默认会使用主键作为聚簇索引的索引键；
- 如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键；
- 在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键；

#### 堆表和索引组织表

**堆表中的数据无序存放，** 数据的排序完全依赖于索引，堆表的组织结构中，数据和索引分开存储。

**索引组织表，数据根据主键排序存放在索引中**，主键索引也叫聚集索引（Clustered Index）。在索引组织表中，数据即索引，索引即数据。

#### 组合索引

由多个列所组合而成的 B+树索引

#### 索引失效

- 当我们使用左或者左右模糊匹配的时候，也就是 `like %xx` 或者 `like %xx%`这两种方式都会造成索引失效；
- 当我们在查询条件中对索引列使用函数，就会导致索引失效。
- 当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。
- MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。
- 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。
- 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。

