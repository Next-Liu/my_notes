## 1.消息队列的作用

**消除峰值**

MQ可以将系统的超量请求暂存其中，以便系统后期可以慢慢进行处理，从而避免了请求的丢失或系统 被压垮。

**异步&解耦**

上游系统对下游系统的调用若为同步调用，则会大大降低系统的吞吐量与并发度，且系统耦合度太高。 而异步调用则会解决这些问题。所以两层之间若要实现由同步到异步的转化，一般性做法就是，在这两层间添加一个MQ层。 即使消费者挂掉也不影响生产者工作，只要把消息放入队列即可，消费者重启后自己消费即可。

**数据收集**

分布式系统会产生海量级数据流，如：业务日志、监控数据、用户行为等。针对这些数据流进行实时或 批量采集汇总，然后对这些数据流进行大数据分析，这是当前互联网平台的必备技术。通过MQ完成此类数据收集是最好的选择。

## 2.RocketMQ的架构

![](D:\学习笔记\消息队列\pictures\Snipaste_2025-03-02_18-48-30.png)

#### **1. NameServer**

- **作用**：
  - NameServer 是 RocketMQ 的轻量级注册中心，负责管理 Broker 的整个路由信息。
  - 生产者和消费者通过 NameServer 获取 Broker 的地址。
- **特点**：
  - 无状态，易于扩展。
  - 通过心跳机制与 Broker 保持通信。

------

#### **2. Broker**

- **作用**：
  - Broker 是 RocketMQ 的核心组件，负责消息的存储和转发。
  - 一个 Broker 可以管理多个 Topic 和 Queue。
- **核心模块**：
  - **CommitLog**：存储所有消息的物理文件，顺序写入。
  - **ConsumeQueue**：存储消息的逻辑队列，按 Topic 和 Queue 分组。每个 Topic 的每个 Queue 对应一个 ConsumeQueue 文件。
  - **IndexFile**：为消息提供索引，支持按 Key 或时间范围查询。
- **特点**：
  - 支持主从架构（Master-Slave），提高可用性。
  - 支持同步刷盘和异步刷盘，平衡性能与可靠性。

------

#### **3. Producer（生产者）**

- **作用**：
  - 生产者负责创建消息并将其发送到 Broker。
- **特点**：
  - 支持同步发送、异步发送和单向发送。
  - 支持消息重试和事务消息。

------

#### **4. Consumer（消费者）**

- **作用**：
  - 消费者从 Broker 订阅消息并进行处理。
- **消费模式**：
  - **集群模式**：一条消息只会被一个消费者消费。
  - **广播模式**：一条消息会被所有消费者消费。
- **特点**：
  - 支持 Push 模式和 Pull 模式。
  - 支持消息重试和死信队列。

------

#### **5. Topic（主题）**

- **作用**：
  - Topic 是消息的逻辑分类，生产者将消息发送到指定的 Topic，消费者订阅感兴趣的 Topic。
- **特点**：
  - 一个 Topic 可以包含多个 Queue，用于负载均衡。

------

#### **6. Queue（队列）**

- **作用**：
  - Queue 是 Topic 的分区，用于实现消息的并行处理。
- **特点**：
  - 一个 Topic 可以有多个 Queue，分布在不同的 Broker 上。
  - 消费者从 Queue 中拉取消息。

## 3.RocketMQ执行流程

1.生产者发送消息

2.消息存储

3.消费者订阅消息

4.消息消费

5.消息重试与死信队列

## 4.Broker的核心组成及高效读写机制

#### 1.**CommitLog**

- **作用**：
  - CommitLog 是 Broker 的核心存储文件，所有消息都顺序写入到 CommitLog 中。
  - 它是消息的物理存储文件，保证了消息的高效写入和读取。
- **特点**：
  - **顺序写入：提高磁盘 I/O 性能。**
    - 优点：减少碎片化、减少磁盘寻址时间、提高吞吐量
  - 零拷贝技术：减少数据复制，提高性能。 **10万条/s**
  - 文件分段：CommitLog 文件按固定大小（默认 1GB）分段存储。

**零拷贝（Zero-Copy）** 是一种优化技术，旨在减少数据在内核空间和用户空间之间的复制次数。

- 传统的数据传输过程中，数据需要从**磁盘读取到内核缓冲区**，再从**内核缓冲区复制到用户缓冲区**，最后发送到网络或存储设备。这个过程涉及多次数据复制，消耗 CPU 和内存资源。
- 零拷贝技术通过减少数据复制次数，提高数据传输效率。

**RocketMQ中零拷贝的实现方式**

1. **mmap（内存映射文件）**

   将磁盘文件直接映射到进程的地址空间，使得应用程序可以像访问内存一样访问文件。数据不需要从内核缓冲区复制到用户缓冲区，减少了数据复制。

   - **RocketMQ 使用 `mmap` 将 CommitLog 文件映射到内存，消费者可以直接从内存中读取消息，避免了数据复制。**

2. ##### **sendfile**系统调用

   允许数据直接从文件描述符传输到网络套接字，而不需要经过用户空间。即数据直接从内核缓冲器直接发送到网络设备

**索引设计：**

使用 ConsumeQueue 和 IndexFile 来加速消息的检索。 

- **ConsumeQueue**：
  - 每个 Topic 的每个 Queue 对应一个 ConsumeQueue 文件。
  - 存储消息的偏移量（Offset）、大小（Size）和 Tag 哈希值。
  - 消费者通过 ConsumeQueue 快速定位消息在 CommitLog 中的位置。
- **IndexFile**：
  - 为消息提供索引，支持按 Key 或时间范围查询消息。
  - 存储消息的 Key、Offset 和时间戳。

------

#### 2.ConsumeQueue

- **作用**：
  - ConsumeQueue 是消息的逻辑队列，按 Topic 和 Queue 分组存储消息的索引。
  - 每个 Topic 的每个 Queue 对应一个 ConsumeQueue 文件。
- **特点**：
  - 存储消息的偏移量（Offset）、大小（Size）和 Tag 哈希值。
  - 消费者通过 ConsumeQueue 快速定位消息在 CommitLog 中的位置。

------

#### 3.**IndexFile**

- **作用**：
  - IndexFile 是为消息提供索引的文件，支持按 Key 或时间范围查询消息。
- **特点**：
  - 存储消息的 Key、Offset 和时间戳。
  - 适用于需要按 Key 查询消息的场景。

## 5.集群消费和广播消费模式

### 集群消费模式

#### **定义**

- 在集群消费模式下，**一条消息只会被消费者组中的一个消费者消费**。
- 消费者组中的多个消费者共同分担消息的消费任务，实现负载均衡。

#### **特点**

- **消息分配**：
  - RocketMQ 会将 Topic 的 Queue 分配给消费者组中的不同消费者。
  - 每个 Queue 只会被一个消费者消费。
- **负载均衡**：
  - 消费者组中的消费者共同分担消息的消费任务，实现负载均衡。
- **适用场景**：
  - 适用于需要高吞吐量和负载均衡的场景，如订单处理、日志收集等。

#### **示例**

- 假设有一个 Topic，包含 4 个 Queue，消费者组中有 2 个消费者。
- RocketMQ 会将 Queue 分配给消费者：
  - 消费者 1 消费 Queue 1 和 Queue 2。
  - 消费者 2 消费 Queue 3 和 Queue 4。

### 广播消费模式

####  **定义**

- 在广播消费模式下，**一条消息会被消费者组中的所有消费者消费**。
- 每个消费者都会收到相同的消息副本。

#### **特点**

- **消息分发**：
  - RocketMQ 会将消息发送给消费者组中的每个消费者。
  - 每个消费者都会独立消费相同的消息。
- **适用场景**：
  - 适用于需要每个消费者都处理相同消息的场景，如配置更新、通知广播等。

#### 示例

- 假设有一个 Topic，消费者组中有 2 个消费者。
- RocketMQ 会将每条消息发送给消费者 1 和消费者 2，两个消费者都会消费相同的消息。

## 6.普通消息

1.同步发送

等待结果的返回，才能继续发送第二条消息

2.异步发送

不用等待结果的返回，就能继续发送第二条消息

SendCallback 是消息发送结果回调。如果：sendResult.getSendStatus() == SendStatus.SEND_OK 表示成功

3.单向发送

送者发送消息后无需等待Broker的结果返回，Broker也不会返回结果，性能高，可靠性低

- **可靠性最高： 同步发送 > 异步发送 > 单向发送**
- **性能最高：单向发送 > 异步发送 > 同步发送**

## 7.延迟消息

![](D:\学习笔记\消息队列\pictures\Snipaste_2025-03-02_20-05-41.png)

## 8.事务消息

如果业务涉及到**多个数据库(多个服务)的写操作，我们需要保证多个数据库同时提交或回滚**，这种夸多个数据库的事务操作叫分布式事务。

![](D:\学习笔记\消息队列\pictures\Snipaste_2025-03-02_20-07-20.png)

用户保存成功，用户的积分也要保存成功，或者都回滚不做任何存储。这种业务场景可以选择RPC**强一致性方案**，也可以选择最终一致性。**我们选择最终一致性**，因为用户注册成功，不要求马上赠送积分，延迟一定时间后再赠送成功也是允许的。所以有了如下模型

![Snipaste_2025-03-02_20-07-26](D:\学习笔记\消息队列\pictures\Snipaste_2025-03-02_20-07-26.png)

如何保证事务消息发送和本地事务的原子性

​	需要一个本地事务检查监听对象（TransactionListener），一是执行本地事务逻辑，二是返回本地事务执行状态

## 9.死信队列

- 死信队列（Dead Letter Queue，DLQ）是用于存储消费失败的消息的队列。当消息消费失败且重试次数达到阈值时，消息会被放入死信队列。

1. **消息消费失败**：
   - 消费者消费消息时，如果处理失败，会向 Broker 返回消费失败的状态。
2. **消息重试**：
   - Broker 会将消息放入重试队列，稍后重新投递给消费者。
   - RocketMQ 支持多次重试，重试次数可以配置。
3. **进入死信队列**：
   - 如果消息重试次数达到阈值（默认 16 次），消息会被放入死信队列。
4. **人工处理**：
   - 死信队列中的消息需要人工干预处理，例如修复业务逻辑后重新投递。

## 10.RocketMQ会丢失消息吗，丢失消息怎么处理

### **生产者丢失消息**

- **原因**：
  - 生产者发送消息时，网络异常或 Broker 宕机，导致消息未成功发送到 Broker。
- **解决方案**：
  - 使用 **同步发送**，确保消息发送成功后再继续后续操作。
  - 启用 **事务消息**，确保消息和本地事务的一致性。
  - 实现 **消息重试机制**，在发送失败时自动重试。

### Broker 丢失消息

#### **Broker的刷盘策略：**

**消息的存储过程**

当生产者发送消息到 RocketMQ 的 Broker 时，消息的存储过程分为两个阶段：

1. **写入内存**：
   - 消息首先被写入到内存中的 **PageCache**（页缓存）。
   - 这一步非常快，因为内存的读写速度远高于磁盘。
2. **写入磁盘**：
   - 消息从内存（PageCache）刷写到磁盘（CommitLog 文件）。
   - 这一步较慢，因为磁盘的 I/O 速度相对较慢。

#### 刷盘策略的两种形式：

#### **1.同步刷盘（SYNC_FLUSH）**

- **定义**：
  - 消息写入内存后，立即将消息刷写到磁盘，等待刷盘完成后再返回成功。
- **工作流程**：
  1. 消息写入内存（PageCache）。
  2. 调用 `fsync` 或 `fdatasync` 系统调用，将数据强制刷写到磁盘。
  3. 刷盘完成后，向生产者返回发送成功的响应。
- **特点**：
  - **高可靠性**：消息写入磁盘后才返回成功，确保消息不会丢失。
  - **低性能**：每次写入都需要等待磁盘 I/O 完成，增加了消息的写入延迟。
- **适用场景**：
  - 对消息可靠性要求极高的场景，如金融交易、支付系统等。

------

#### 2.异步刷盘（ASYNC_FLUSH）

- **定义**：
  - 消息写入内存后立即返回成功，然后由后台线程定期将内存中的消息批量刷写到磁盘。
- **工作流程**：
  1. 消息写入内存（PageCache）。
  2. 立即向生产者返回发送成功的响应。
  3. 后台线程定期（默认每 500ms）将内存中的消息批量刷写到磁盘。
- **特点**：
  - **高性能**：消息写入内存后立即返回成功，减少了写入延迟。
  - **低可靠性**：如果 Broker 在消息刷盘前宕机，未刷盘的消息可能会丢失。
- **适用场景**：
  - 对性能要求较高、允许少量消息丢失的场景，如日志收集、监控数据等。





- **原因**：
  - Broker 刷盘策略配置不当（如异步刷盘时机器宕机，未刷盘的消息丢失）。
  - 磁盘损坏或硬件故障导致消息丢失。
- **解决方案**：
  - 使用 **同步刷盘**（flushDiskType=SYNC_FLUSH），确保消息写入磁盘后再返回成功。
  - 配置 **主从复制**（同步复制或异步复制），确保消息在多个 Broker 上有备份。
  - 定期备份 CommitLog 和 ConsumeQueue 文件，防止硬件故障导致数据丢失。

## 11.RocketMQ如何保证幂等性和避免重复消费

### **1. 消息幂等性**

消息幂等性是指同一条消息被多次处理时，产生的效果与只处理一次时相同。以下是实现消息幂等性的方法：

#### （1）基于唯一标识的幂等性

- **消息ID**：RocketMQ为每条消息分配一个唯一的`messageId`。消费者在处理消息时，可以将`messageId`存储到数据库或其他存储系统中，通过查询`messageId`来判断消息是否已经被处理。
- **业务唯一标识**：在某些场景下，`messageId`可能不足以保证幂等性（例如批量发送或事务消息）。此时可以使用业务逻辑中的唯一标识（如订单ID）作为幂等性判断的依据。

#### （2）使用数据库或缓存实现幂等性

- **数据库唯一约束**：将消息的唯一标识（`messageId`或业务唯一标识）存储到数据库中，并设置唯一约束。如果尝试插入重复的标识，则认为消息已被处理。
- **Redis SETNX命令**：利用Redis的`SETNX`命令（Set if not exists），在处理消息之前，将消息的唯一标识作为key存入Redis。如果key已存在，说明消息已被处理。

### 2.避免重复消费

#### （1）消费确认机制

RocketMQ支持同步确认、异步确认和批量确认。在消费消息后，消费者需要向Broker发送确认消息，以确保消息被成功处理。

#### （2）消费重试机制

RocketMQ支持消息重试，但重试可能导致消息重复消费。可以通过配置合理的重试次数和间隔，减少重复消费的可能性。

#### （3）死信队列

对于无法正常消费的消息，RocketMQ会将它们放入死信队列。通过监控死信队列，可以及时发现和处理异常消息。