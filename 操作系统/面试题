## 1.进程线程协程区别

- **进程**：
  - 进程是操作系统分配资源的基本单位，是程序的一次执行实例。
  - 每个进程都有自己独立的内存空间、系统资源（如文件描述符、信号处理等）。
  - 进程之间的切换通常涉及较大的开销，因为操作系统需要保存和恢复每个进程的上下文。
  
- **线程**：
  - 线程是进程中的一个执行单元，是操作系统能够进行运算调度的最小单位。
  
  - 线程共享所属进程的内存空间和其他资源，但每个线程有自己的**栈空间（存储局部变量、方法调用信息和返回值）和程序计数器（记录当前线程执行到的指令地址）。**
  
    **因为不同线程可能执行不同的方法调用链，需要独立存储；局部变量是线程私有的，不能被其他线程访问。**
  
    **不同线程可能执行不同的代码路径，需要独立记录执行位置。**
  
  - 线程之间的切换开销较小，因为它们共享相同的上下文。
  
    - 共享相同的地址空间（代码段、数据段、堆）
    - 共享进程打开的文件、全局变量等资源
  
- **协程**：

  - 协程是一种轻量级的线程，由用户态调度，可创建大量协程，非阻塞（在等待 I/O 操作（如网络请求、文件读写）时暂停，让出 CPU 资源给其他协程，从而避免阻塞线程）

  - | **特性**     | **线程**                     | **协程**                           |
    | ------------ | ---------------------------- | ---------------------------------- |
    | **调度方式** | 由操作系统调度               | 由用户显式控制                     |
    | **切换开销** | 较高，涉及内核态和用户态切换 | 较低，完全在用户态完成             |
    | **并发能力** | **受限于 CPU 核心数**        | **可创建大量协程，适合高并发场景** |
    | **阻塞问题** | 阻塞线程会导致资源浪费       | 协程暂停时不会阻塞线程             |

## 2.进程之间的通信方式

#### 管道

- **匿名管道**：仅限于具有亲缘关系的进程之间通信（如父子进程）。
- **命名管道**：通过文件系统中的一个特殊文件（FIFO）实现，允许不相关的进程通信。进程可以通过读写这个文件进行通信

#### 消息队列

#### 共享内存

- 多个进程可以访问同一块内存区域，从而实现高效的数据共享。

## 3.线程之间的通信方式

### 1.同步机制

1. **互斥锁（Mutex）**
   - 用于保护共享资源，确保同一时间只有一个线程可以访问。
   - 应用场景：防止多个线程同时修改共享数据，避免数据不一致。
2. **条件变量（Condition Variable）**
   - 用于线程间的协调，允许线程在满足特定条件时被唤醒。
   - 应用场景：生产者-消费者模型，一个线程等待另一个线程完成任务。
3. **信号量（Semaphore）**
   - 用于控制对共享资源的访问，限制同时访问资源的线程数量。
   - 应用场景：资源池管理，如数据库连接池。

### 2.共享内存

​	线程可以直接访问进程的全局变量或堆内存，从而实现数据共享。

## 4.死锁以及死锁的解决方法

死锁（Deadlock）是指多个进程或线程在执行过程中，因争夺资源而造成的一种互相等待的现象，导致这些进程或线程都无法继续执行下去。

### **死锁的四个必要条件**

1. **互斥条件**：资源一次只能被一个进程或线程占用。
2. **请求与保持**：进程或线程持有至少一个资源，并等待获取其他被占用的资源。
3. **非剥夺条件**：已分配给进程或线程的资源，不能被其他进程或线程强行夺取，必须由持有者自行释放。
4. **循环等待条件**：存在一个进程或线程的循环链，每个进程或线程都在等待下一个进程或线程所占用的资源。

## 死锁预防（破坏四个必要条件中的一个）

破坏“占有且等待”条件：所有的进程在开始运行之前，必须一次性地申请其在整个运行过程中所需要的全部资源。

破坏“不可抢占”条件：当一个已经持有了一些资源的进程在提出新的资源请求没有得到满足时，它必须释放已经保持的所有资源，待以后需要使用的时候再重新申请。这就意味着进程已占有的资源会被短暂地释放或者说是被抢占了。

破坏“循环等待”条件：可以通过定义资源类型的线性顺序来预防，可将每个资源编号，当一个进程占有编号为i的资源时，那么它下一次申请资源只能申请编号大于i的资源。

## 死锁避免（银行家算法）

可利用资源向量（1*m）

最大需求矩阵Max（n*m）

分配矩阵Allocation（n*m）：对各个进程已经分配的资源数目

需求矩阵Need：用于表示进程仍然需要的资源数目（n*m）进程的最大需求减去已经分配给进程的数目，就得到了进程仍然需要的资源数目了。 

看是否可以找到一个安全队列，使得所有进程执行完毕（进程执行完毕回收已分配的资源），如果可以，则系统处于安全状态

