## 1.进程线程协程区别

- **进程**：
  - 进程是操作系统分配资源的基本单位，是程序的一次执行实例。
  - 每个进程都有自己独立的内存空间、系统资源（如文件描述符、信号处理等）。
  - 进程之间的切换通常涉及较大的开销，因为操作系统需要保存和恢复每个进程的上下文。
  
- **线程**：
  - 线程是进程中的一个执行单元，是操作系统能够进行运算调度的最小单位。
  
  - 线程共享所属进程的内存空间和其他资源，但每个线程有自己的**栈空间（存储局部变量、方法调用信息和返回值）和程序计数器（记录当前线程执行到的指令地址）。**
  
    **因为不同线程可能执行不同的方法调用链，需要独立存储；局部变量是线程私有的，不能被其他线程访问。**
  
    **不同线程可能执行不同的代码路径，需要独立记录执行位置。**
  
  - 线程之间的切换开销较小，因为它们共享相同的上下文。
  
    - 共享相同的地址空间（代码段、数据段、堆）
    - 共享进程打开的文件、全局变量等资源
  
- **协程**：

  - 协程是一种轻量级的线程，由用户态调度，可创建大量协程，非阻塞（在等待 I/O 操作（如网络请求、文件读写）时暂停，让出 CPU 资源给其他协程，从而避免阻塞线程）

  - | **特性**     | **线程**                                                     | **协程**                           |
    | ------------ | ------------------------------------------------------------ | ---------------------------------- |
    | **调度方式** | 由操作系统调度                                               | 由用户显式控制                     |
    | **切换开销** | 较高，涉及内核态和用户态切换（时间片用完、阻塞、更高优先级的线程的到来，**内核态**：CPU 寄存器、栈、程序计数器等资源的保存和恢复以及线程的调度。） | 较低，完全在用户态完成             |
    | **并发能力** | **受限于 CPU 核心数**                                        | **可创建大量协程，适合高并发场景** |
    | **阻塞问题** | 阻塞线程会导致资源浪费                                       | 协程暂停时不会阻塞线程             |

### 切换线程开销大的原因：

- **用户态到内核态**：当线程切换发生时，当前线程从用户态切换到内核态，由操作系统保存其上下文。
- **内核态到用户态**：操作系统选择下一个线程并恢复其上下文，然后从内核态切换回用户态，执行新线程。

## 2.进程之间的通信方式

#### 管道

- **匿名管道**：仅限于具有亲缘关系的进程之间通信（如父子进程）。
- **命名管道**：通过文件系统中的一个特殊文件（FIFO）实现，允许不相关的进程通信。进程可以通过读写这个文件进行通信

#### 消息队列

#### 共享内存

- 多个进程可以访问同一块内存区域，从而实现高效的数据共享。

## 3.线程之间的通信方式

### 1.同步机制

1. **互斥锁（Mutex）**
   - 用于保护共享资源，确保同一时间只有一个线程可以访问。
   - 应用场景：防止多个线程同时修改共享数据，避免数据不一致。
2. **条件变量（Condition Variable）**
   - 用于线程间的协调，允许线程在满足特定条件时被唤醒。
   - 应用场景：生产者-消费者模型，一个线程等待另一个线程完成任务。
3. **信号量（Semaphore）**
   - 用于控制对共享资源的访问，限制同时访问资源的线程数量。
   - 应用场景：资源池管理，如数据库连接池。

### 2.共享内存

​	线程可以直接访问进程的全局变量或堆内存，从而实现数据共享。

## 4.切换进程有哪些步骤

#### 1**. 触发进程切换**

进程切换通常由以下事件触发：

- **时间片用完**：操作系统的时间片调度机制强制切换进程。
- **系统调用**：进程主动请求操作系统服务（如 I/O 操作）。
- **中断**：硬件中断（如时钟中断、I/O 完成中断）导致 CPU 切换到内核态。
- **阻塞**：进程等待某个事件（如 I/O 完成）而主动放弃 CPU。

#### **2. 保存当前进程的上下文**

操作系统需要保存当前进程的状态，以便后续恢复执行。上下文包括：

- **CPU 寄存器**：如程序计数器（PC）、栈指针（SP）、通用寄存器等。
- **程序计数器（PC）**：保存当前进程的下一条指令地址。
- **栈指针（SP）**：保存当前进程的栈位置。
- **进程控制块（PCB）**：保存进程的元数据，如进程 ID、状态、优先级等。
- **内存管理信息**：如页表、段表等（如果支持虚拟内存）。

这些信息通常保存在进程的 **PCB（Process Control Block）** 中。

#### **3. 选择下一个要运行的进程**

操作系统根据调度算法（如轮转调度、优先级调度）从就绪队列中选择下一个要运行的进程。

#### **4. 恢复下一个进程的上下文**

操作系统从下一个进程的 PCB 中恢复其上下文，包括：

- **CPU 寄存器**：恢复寄存器的值。
- **程序计数器（PC）**：恢复进程的下一条指令地址。
- **栈指针（SP）**：恢复进程的栈位置。
- **内存管理信息**：恢复页表或段表（如果支持虚拟内存）。

#### **5. 切换到用户态并执行**

## 5.死锁以及死锁的解决方法

死锁（Deadlock）是指多个进程或线程在执行过程中，因争夺资源而造成的一种互相等待的现象，导致这些进程或线程都无法继续执行下去。

#### **死锁的四个必要条件**

1. **互斥条件**：资源一次只能被一个进程或线程占用。
2. **请求与保持**：进程或线程持有至少一个资源，并等待获取其他被占用的资源。
3. **非剥夺条件**：已分配给进程或线程的资源，不能被其他进程或线程强行夺取，必须由持有者自行释放。
4. **循环等待条件**：存在一个进程或线程的循环链，每个进程或线程都在等待下一个进程或线程所占用的资源。

### 5.1死锁预防（破坏四个必要条件中的一个）

破坏“占有且等待”条件：所有的进程在开始运行之前，必须**一次性地申请其在整个运行过程中所需要的全部资源**。

破坏“不可抢占”条件：当一个已经持有了一些资源的进程在提出新的资源请求没有得到满足时，它必须释放已经保持的所有资源，待以后需要使用的时候再重新申请。这就意味着进程已占有的资源会被短暂地释放或者说是被抢占了。

破坏“循环等待”条件：可以通过定义资源类型的线性顺序来预防，可将每个资源编号，当一个进程占有编号为i的资源时，那么它下一次申请资源只能申请编号大于i的资源。

### 5.2死锁避免（银行家算法）

可利用资源向量（1*m）

最大需求矩阵Max（n*m）

分配矩阵Allocation（n*m）：对各个进程已经分配的资源数目

需求矩阵Need：用于表示进程仍然需要的资源数目（n*m）进程的最大需求减去已经分配给进程的数目，就得到了进程仍然需要的资源数目了。 

看是否可以找到一个安全队列，使得所有进程执行完毕（进程执行完毕回收已分配的资源），如果可以，则系统处于安全状态

## 6.IO多路复用

一种 **提高系统 I/O 效率** 的技术，它允许一个进程同时监听多个 I/O 事件，而不必为每个 I/O 连接创建一个线程或进程。常见的 **I/O 多路复用机制**有select、poll、epoll

#### **I/O 多路复用的优势**

 **单线程可以同时处理多个 I/O 事件**
 **减少线程开销，避免上下文切换**
 **适用于高并发场景（如 Web 服务器、消息队列）**

### I/O 多路复用的几种方式

#### 1.select

​	通过 **一个文件描述符集合（fd_set）** 监视多个文件描述符的状态（读、写、异常）来实现 I/O 操作。

​	需要 **遍历整个集合**，性能较低（O(n)）。

​    **最大支持 1024 个文件描述符**（`FD_SETSIZE = 1024`）。

- 每次调用需要将文件描述符集合从用户态拷贝到内核态。

具体流程：

1. 将文件描述符集合从用户态拷贝到内核态。
2. 内核遍历文件描述符集合，检查是否有事件发生。
3. 将发生事件的文件描述符集合从内核态拷贝回用户态。
4. 用户程序遍历文件描述符集合，处理事件。

#### 2.poll

​	通过 `pollfd` 结构体来监视文件描述符的状态。

​	用 **动态数组**（`struct pollfd`）代替 `select` 的 **固定大小数组**，突破 1024 限制。

​	**遍历整个数组**，性能仍然是 O(n)。

- 每次调用需要将文件描述符集合从用户态拷贝到内核态。

具体流程：

1. 将 `pollfd` 结构体数组从用户态拷贝到内核态。
2. 内核遍历 `pollfd` 结构体数组，检查是否有事件发生。
3. 将发生事件的 `pollfd` 结构体数组从内核态拷贝回用户态。
4. 用户程序遍历 `pollfd` 结构体数组，处理事件。

#### 3.epoll

​	是 Linux 特有的多路复用 I/O 模型，通过事件驱动的方式监视文件描述符的状态。

​	文件描述符数量不受限制。

​	**只需将文件描述符集合拷贝到内核态一次**，后续通过事件通知机制更新。

具体流程：

1. 调用 `epoll_create` 创建一个 `epoll` 实例。
2. 调用 `epoll_ctl` 将文件描述符注册到 `epoll` 实例中。
3. 调用 `epoll_wait` 等待事件发生。
4. 内核通过**事件通知机制将发生事件的文件描述符返回给用户程序。**

## 7.内核态和用户态，这样设计的优缺点

内核态和用户态是操作系统对 CPU 运行权限的一种划分机制。为了提高系统的安全性、稳定性和资源管理能力

### **优点**

1. **安全性**
   - **权限隔离**：内核态拥有最高权限，可以直接访问硬件和系统资源；用户态权限受限，无法直接访问硬件或关键系统资源。这种隔离防止了用户程序对系统的恶意破坏或误操作。
   - **防止越权访问**：用户程序必须通过系统调用（fork()、wait()、open()、close()、write()、read()）请求内核提供服务，内核会对请求进行合法性检查，防止非法操作。
2. **稳定性**
   - **错误隔离**：用户程序的崩溃通常不会影响内核和其他程序的运行，因为用户态程序无法直接修改内核数据或硬件状态。
   - **内核保护**：内核态代码经过严格测试和验证，减少了系统崩溃的可能性。
3. **资源管理**
   - **统一调度**：内核负责管理 CPU、内存、设备等资源，确保资源的公平分配和高效利用。
   - **抽象硬件**：内核为上层应用程序提供统一的硬件抽象接口，简化了应用程序的开发。
4. **多任务支持**
   - **进程隔离**：内核通过虚拟内存和进程调度机制，确保不同用户程序之间的隔离和独立运行。
   - **并发控制**：内核提供同步机制（如锁、信号量）来协调多个进程或线程的并发访问。

------

### **缺点**

1. **性能开销**
   - **上下文切换**：用户态和内核态之间的切换（如系统调用）需要保存和恢复 CPU 状态，导致额外的性能开销。
   - **频繁的系统调用**：如果应用程序需要频繁请求内核服务，性能会显著下降。
2. **开发复杂性**
   - **系统调用限制**：用户程序无法直接访问硬件或某些系统资源，必须通过系统调用，增加了开发的复杂性。
   - **调试困难**：内核态代码的调试比用户态更复杂，因为内核态错误可能导致系统崩溃。
3. **灵活性受限**
   - **权限限制**：用户态程序无法直接控制硬件或执行某些特权操作，限制了某些高性能或实时应用的需求。
   - **定制化困难**：内核提供的抽象接口可能无法满足所有应用程序的特定需求。
4. **潜在的单点故障**
   - **内核崩溃**：如果内核本身出现错误（如内存泄漏或死锁），整个系统可能崩溃，影响所有用户程序。