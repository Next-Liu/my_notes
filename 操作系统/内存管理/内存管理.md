## 为什么要有虚拟内存

​	用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易(有意或者无意)破坏操作系统，造成操作系统崩溃。
​	想要同时运行多个程序特别困难，比如你想同时运行一个微信和一个 QQ 音乐都不行。为什么呢?举个2简单的例子:微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就造成微信这个程序会崩溃



​	我们可以把进程所使用的地址「隔离」开来，即让操作系统为每个进程分配独立的一套「虚拟地址」，人
人都有，大家自己玩自己的地址就行，互不干涉。

![](D:\学习笔记\操作系统\pictures\Snipaste_2025-03-03_21-36-32.jpg)

程序在访问相同虚拟地址的时候，由操作系统转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。
	**我们程序所使用的内存地址叫做「虚拟内存地址」**

​	**实际存在硬件里面的空间地址叫「物理内存地址」**

有了虚拟内存后，进程只能操作虚拟内存，不能操作物理内存，每个进程的虚拟地址空间是相互独立的进程不能访问其他进程的虚拟地址，这就解决了多进程之间地址冲突的问题。还有虚拟内存可以使得进程对运行内存超过物理内存大小，通过将没有被经常使用到的内存换出到物理内存之外，比如硬盘上的 swap 区域，只在需要时再将数据加载到内存中。

## 内存分段

​	![](D:\学习笔记\操作系统\pictures\Snipaste_2025-03-03_21-59-27.jpg)

![Snipaste_2025-03-03_22-03-20](D:\学习笔记\操作系统\pictures\Snipaste_2025-03-03_22-03-20.jpg)

## 内存分页

**把内存空间划分为大小相等且固定的块，作为主存的基本单位。**因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，因此需要一个**页表来记录映射关系**，以实现从**页号到物理块号的映射**。访问分页系统中内存数据需要两次的内存访问(**一次是从内存中访问页表，从中找到指定的物理块号，加上页内偏移得到实际物理地址**;

第二次就是根据第一次得到的物理地址访问内存取出数据)。

![](D:\学习笔记\操作系统\pictures\Snipaste_2025-03-03_22-04-16.jpg)

## 段式管理和页式管理有无内存碎片

段式管理没有内部碎片，有外部碎片

页式管理有内部碎片，没有外部碎片

因为页的大小是固定的，假设某一段的机器码没有达到页的大小，产生内部碎片

段式管理可以根据需求分配空间，故没有内部碎片

## 页面置换算法

![](D:\学习笔记\操作系统\pictures\Snipaste_2025-03-03_22-23-25.jpg)

## 数组的物理空间是连续的吗？

虚拟地址连续，物理地址不连续。

## fork的写时复制是如何实现？

当一个进程调用 fork()系统调用创建子进程时，**操作系统会复制父进程的页表**，初始状态下，**父进程和子进程共享相同的物理内存页，这些页在页表中被标记为共享**，所以创建子进程的时候，实际上是**复制父进程的页表**(虚拟内存)，这时候**并不是复制物理内存**，而是共享物理内存。
父进程和子进程都可以读取共享内存页中的数据，而不会触发写时复制机制，读取操作不会导致物理内存页的复制。

当父进程或者子进程对这片共享的内存数据进行了写操作，发现页表是只读的属性，这时候就会**发生写保护中断**，**内核就会为发生中断的进程分配新的物理内存**，**把老的物理页的数据拷贝进这个新的物理页，然后将最新的数据写入到这个新的物理页**，最后把**发生中断的虚拟地址映射到新的物理页**，同时该进程的页表的权限设置为可读写，这就完成了一次写时复制。