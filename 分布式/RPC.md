### RPC的概念

​	RPC的全称是Remote Procedure Call，即远程过程调用。是指要跨机器而非本机，所以需要用到网络编程才能实现，但是不是只要通过网络通信访问到另一台机器的应用程序

​	**RPC框架能够帮助我们解决系统拆分后的通信问题，并且能让我们像调用本地一样去调用远程方法。**利用RPC我们不仅可以很方便地将应用架构从“单体”演进成“微服务化”，而且还能解决实际开发过程中的效率低下、系统耦合等问题，这样可以使得我们的系统架构整体清晰、健壮，应用可运维度增强。

​	一次RPC调用，本质就是服务消费者与服务提供者间的一次网络信息交换的过程。

### 对象在网络的传输

![](D:\学习笔记\分布式\pictures\Snipaste_2024-04-18_11-30-24.png)

### 序列化方式

![](D:\学习笔记\分布式\pictures\Snipaste_2024-04-18_11-48-40.png)

序列化过程就是在读取对象数据的时候，不断加入一些特殊分隔符，这些特殊分隔符用于在反序列化过程中截断用。

- 头部数据用来声明序列化协议、序列化版本，用于高低版本向后兼容
- 对象数据主要包括类名、签名、属性名、属性类型及属性值，当然还有开头结尾等数据，除了属性值属于真正的对象值，其他都是为了反序列化用的元数据
- 存在对象引用、继承的情况下，就是递归遍历“写对象”逻辑

1.实现Serializable

2.JSON

3.Hession

Hessian协议要比JDK、JSON更加紧凑，性能上要比JDK、JSON序列化高效很多，而且生成的字节数也更小。

```java
Student student = new Student();
student.setNo(101);
student.setName("HESSIAN");

//把student对象转化为byte数组
ByteArrayOutputStream bos = new ByteArrayOutputStream();
Hessian2Output output = new Hessian2Output(bos);
output.writeObject(student);
output.flushBuffer();
byte[] data = bos.toByteArray();
bos.close();

//把刚才序列化出来的byte数组转化为student对象
ByteArrayInputStream bis = new ByteArrayInputStream(data);
Hessian2Input input = new Hessian2Input(bis);
Student deStudent = (Student) input.readObject();
input.close();

System.out.println(deStudent);
```

### 序列化方式的选择

1.序列化协议的通用性和兼容性：一个具有高通用性的序列化协议应该能够支持在不同的操作系统和编程语言之间传输数据。一个具有良好兼容性的序列化协议应该能够支持向后兼容，即新版本的代码能够理解和处理旧版本的数据格式。

2.空间开销：序列化之后的二进制数据占用的空间大小

3.安全性：JDK原生序列化方式有以下漏洞：**远程代码执行（RCE）**: 攻击者可以通过精心构造的恶意序列化数据，在反序列化时执行任意代码。这种情况下，攻击者可以完全控制程序的行为，可能导致敏感数据泄露、系统崩溃或其他严重后果。

### RPC框架

![](D:\学习笔记\分布式\pictures\Snipaste_2024-09-10_10-17-32.png)



### 常见的网络IO模型

阻塞IO：

​	应用进程发起IO系统调用后，应用进程被阻塞，转到内核空间处理。之后，内核开始等待数据，等待到数据之后，再将内核中的数据拷贝到用户内存中

![](D:\学习笔记\分布式\pictures\Snipaste_2024-12-25_15-20-13.png)

IO多路复用：

![](D:\学习笔记\分布式\pictures\Snipaste_2024-12-25_16-54-29.png)

​	常规方法是使用多进程/线程模型，每来一个客户端连接，就分配一个进程/线程，然后后续的读写都在对应的进程/线程，这种方式处理 100 个客户端没问题，但是当客户端增大到 10000 个时，10000 个进程/线程的调度、上下文切换以及它们占用的内存，都会成为瓶颈。

​	**多路指多个网络连接IO，复用指多个通道在一个复用器上**

​	多个网络连接的IO可以注册到一个复用器（select）上，当用户进程调用了select，那么整个进程会被阻塞。同时，内核会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从内核中拷贝到用户进程。

RPC调用在大多数的情况下，**是一个高并发调用的场景**，考虑到系统内核的支持、编程语言的支持以及IO模型本身的特点，在RPC框架的实现中，在网络通信的处理上，选择IO多路复用的方式

`java.nio` 包提供的 `Selector` 来实现 I/O 多路复用。

**Selector** 允许一个单独的线程同时管理多个通道（Channel），通过轮询的方式监听多个通道是否准备好进行读写操作，从而实现多路复用。

常见的 I/O 多路复用模式有：

- **轮询（Polling）**：每次检查所有通道的状态，适用于较少连接的场景。
- **事件驱动（Event-Driven）**：基于事件的驱动机制，一旦某个通道准备好，立即进行处理。

![](D:\学习笔记\分布式\pictures\Snipaste_2024-12-25_17-58-12.png)

### 什么是零拷贝？

​	系统内核处理IO操作分为两个阶段——等待数据和拷贝数据。等待数据，就是系统内核在等待网卡接收到数据后，把数据写到内核中；而拷贝数据，就是系统内核在获取到数据后，将数据拷贝到用户进程的空间中。



![](D:\学习笔记\分布式\pictures\Dingtalk_20240910191143.jpg)

由图中看出，应用程序进行一次完整的读/写操作，需要进行两次拷贝，**每一次拷贝，都需要CPU进行一次上下文切换（由用户进程切换到系统内核，或由系统内核切换到用户进程）**，浪费cpu性能。

零拷贝就是**取消用户空间与内核空间之间的数据拷贝操作**，应用进程每一次的读写操作，都可以通过一种方式，让应用进程向用户空间写入或者读取数据，就如同直接向内核空间写入或者读取数据一样，再通过DMA将内核中的数据拷贝到网卡，或将网卡中的数据copy到内核。

![](D:\学习笔记\分布式\pictures\Snipaste_2024-12-25_17-57-04.png)

两种方式：

mmap+write 方式和 sendfile 方式

### RPC框架

**传输层**：负责数据的序列化、压缩、网络传输。

**协议层**：负责协议封装、解封装。

**服务发现与连接层**：负责服务的注册、发现和连接管理。

**服务治理层**：负责服务的健康监控、负载均衡、流量控制等。

![](D:\学习笔记\分布式\pictures\Snipaste_2024-12-25_18-57-31.png)

### 服务发现

![](D:\学习笔记\分布式\pictures\Snipaste_2024-12-25_19-57-51.png)

1. 服务注册：在服务**提供方启动**的时候，将对外暴露的接口注册到注册中心之中，注册中心将这个**服务节点的IP和接口**保存下来。
2. 服务订阅：在服务**调用方启动**的时候，去**注册中心**查找并订阅服务提供方的IP，然后缓存到本地，并用于后续的远程调用。

### 基于ZooKeeper的服务发现

![](D:\学习笔记\分布式\pictures\Snipaste_2024-12-25_22-32-50.png)

1. 服务平台管理端先在ZooKeeper中**创建一个服务根路径**，可以根据接口名命名（例如：/service/com.demo.xxService），在这个路径**再创建服务提供方目录与服务调用方目录（例如：provider、consumer）**，分别用来**存储服务提供方的节点信息和服务调用方的节点信息**。

2. 当服务提供方发起注册时，会在服务提供方目录中创建一个临时节点，节点中存储该服务提供方的注册信息。

3. 当服务调用方发起订阅时，则在服务调用方目录中创建一个临时节点，节点中存储该服务调用方的信息，同时服务调用方**watch该服务的服务提供方目录（/service/com.demo.xxService/provider）中所有的服务节点数据**。

4. 当服务提供方目录下有节点数据发生变更时，ZooKeeper就会通知给发起订阅的服务调用方。


### 基于消息总线的最终一致性的注册中心

