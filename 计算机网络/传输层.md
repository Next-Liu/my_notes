## 1.TCP滑动窗口

发送方和接收方在内核各自都有一个缓冲区，发送缓冲区和接收缓冲区上都各有一个窗口，发送方的窗口表示可发送的最大数据量，接收方的窗口表示可接收的最大数据量，
发送方有了发送窗口后，那么发送方可以不用等待已发送数据的确认报文，就可以继续发送下一批数据，提高了发送的速率，
接收方有了接收窗口后，可以实现流量控制，把接收方的接收窗口告诉给发送方，让发送方按自己的接收情况来发送数据，避免发送方发送的数据过快，导致接收方处理不过来。

## 2.TCP的拥塞控制

TCP协议能够根据网络状况动态调整发送速率，避免因为过大的流量导致网络拥塞。导致数据包丢失、延迟增加等问题。

拥塞控制算法有慢启动、拥塞避免、超时重传、快恢复

1.慢启动:

​	发送方开始时设置一个较小的拥塞窗口大小，
​	然后每收到一个确认，窗口大小就翻倍，以指数方式增长，直到拥塞控制窗口达到**慢启动门限**。
2拥塞避免:当窗口大小达到慢启动门限后，就进入拥塞避免阶段，此时拥塞窗口大小每收到一个确认，就增加一个报文段的大小，以**线性方式增长**。
3.拥塞发生:随着发送速率慢慢增长，**可能网络会出现拥塞，发生了数据包丢失，这时候就需要重传数据，重传机制主要有两种**，一个是超时重传和快速重传。
​	3.1超时重传:当发生了超时重传（发送方在超时时间内未收到ACK），慢启动门限会设置为拥塞窗口的一半，并且将拥塞窗口恢复为初始值，接着,就重新开始慢启动，发送速率就会瞬间下降了很多。
​	3.2快速重传和快速恢复:当发送方连续收到三个重复确认时，就认为发生了丢包，此时**拥塞窗口门限**会被设置为当前拥塞窗口的一半，拥塞窗口被设置成门限+3大小，是为了补偿已经收到的 3 个重复 ACK，表示有 3 个数据包已经成功到达接收方。

## 3.TCP的四次挥手

![](D:\学习笔记\计算机网络\pictures\Snipaste_2025-03-20_19-39-18.png)

客户端打算关闭连接，此时会发送一个 FIN 报文，之后客户端进入FIN_WAIT_1 状态。

服务端收到 FIN 报文后，就向客户端发送 ACK应答报文，接着服务端进入CLOSE WAIT 状态

客户端收到服务端的 ACK应答报文后，之后进入FIN_WAIT_2状态等待服务端处理完数据后，也向客户端发送 FIN报文，之后服务端进入LAST_ACK状态

客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文，之后进入 TIME WAIT 状态

服务端收到了 ACK应答报文后，就进入了CLOSE 状态，至此服务端已经完成连接的关闭。

客户端在 TIME WAIT 状态经过 2MSL一段时间后，自动进入 CLOSE 状态，至此客户端也完成连接的关闭。

### **TIME_WAIT和CLOSE_WAIT大量存在分别会有什么影响？**

#### 大量 `TIME_WAIT` 的影响

​	如果客户端(主动发起关闭连接方)的 TIME_WAIT 状态过多，占满了所有端口资源，那么就无法对「目的 IP+ 目的 PORT都一样的服务端发起连接了，但是被使用的端口，还是可以继续对另外一个服务端发起连接的,

​	如果服务端(主动发起关闭连接方)的 TIME_WAIT 状态过多，并不会导致端口资源受限，因为服务端只监听端口，而且由于一个四元组唯一确定一个 TCP 连接，因此理论上服务端可以建立很多连接,但是 TCP 连接过多会占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等。

#### 解决方法：

- **重用端口**：通过设置 `SO_REUSEADDR` 和 `SO_REUSEPORT` 选项，允许重用处于 `TIME_WAIT` 状态的端口。
- **长连接**：尽量使用长连接，减少短连接的创建和关闭。
- **调整 `TIME_WAIT` 时间**：修改内核参数，减少 `TIME_WAIT` 的持续时间（例如，将 `net.ipv4.tcp_fin_timeout` 设置为较小的值）。

**出现原因：**

​	没有使用长连接

#### CLOSE_WAIT状态产生的原因

CLOSE_WAIT 状态是**「被动关闭方」**才会有的状态，而且如果「被动关闭方」没有调用 close 函数关闭连接，那么就无法发出 FIN 报文，从而无法使得 CLOSE_WAIT 状态的连接转变为 LAST_ACK 状态所以，当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接。