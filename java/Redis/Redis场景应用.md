### 1.缓存

给数据库做存储缓存，将MySQL的热点数据存储在Redis上，一般为二八原则，80%的流量，20%的热点数据，可以提高系统的吞吐量

一般分为服务器端缓存和客户端缓存，服务器端缓存是可以用Redis将数据库数据存储，客户端缓存是对服务器端远程调用后，结果存储在客户端，这样下次请求相同数据可以直接拿到结果。

微服务架构下，每个服务器都应存储一些热点数据

对于频繁请求的数据，可以做客户端缓存

#### 缓存的几种模式

1.cache aside（旁路缓存）

读操作：

![](D:\学习笔记\java\pictures\Snipaste_2023-12-27_21-16-36.png)

写操作：

![](D:\学习笔记\java\pictures\Snipaste_2023-12-27_21-18-38.png)

删除缓存后，在下次读取时更新缓存

使用场景：读多写少，数据写入后不怎么会修改，但会出现数据库的内容和缓存数据不一致的问题。

2.read through（读穿透）

应用服务不再和缓存直接交互，直接访问数据服务，可以理解为一个代理，单独的一个服务用来访问数据库和缓存，查询的时候和cache aside相同

3.write through（写穿透）

有存储服务写写入MySql，再同步写入缓存

4.write behind（异步缓存写入）

先写缓存，然后异步把数据写入数据库

#### 缓存异常的场景

##### 1.缓存穿透

访问缓存和数据库都没有的数据，且用户一直发起请求。由于缓存是访问不命中去写，这将导致每次请求都去访问数据库，失去缓存的意义。在流量很大时，数据库可能挂掉

**解决方案**

![](D:\学习笔记\java\pictures\Snipaste_2023-12-28_16-47-26.png)

方法2本质还是减小数据库的压力

##### 2.缓存击穿（一般为某个热点key过期）

缓存中没有但数据库有（一般为缓存到期），这时并发用户突然增多，缓存没有，都去访问数据库，导致数据库压力骤增。

![](D:\学习笔记\java\pictures\Snipaste_2023-12-28_17-10-57.png)

##### 3.缓存雪崩（大批key过期）

缓存中大批量数据到期，而查询数据量过大，引起数据库压力过大宕机。

![](D:\学习笔记\java\pictures\Snipaste_2023-12-28_17-16-28.png)

#### 缓存一致性如何保证

1.更新数据库，不管Redis，等待缓存过期失效，再从数据库拉取

2.

![](D:\学习笔记\java\pictures\Snipaste_2023-12-28_21-41-31.png)

3.![](D:\学习笔记\java\pictures\Snipaste_2023-12-28_21-54-46.png)

消费服务就是这里的binlog client，也就是一个slave，可以当作MySQL的一个跟随者，MySQL的操作这个slave都可以接收到。好处是与业务完全解耦，更新MySQL时无需额外操作。

适合缓存数据不过期或者很长时间不过期场景

![Snipaste_2023-12-28_21-54-56](D:\学习笔记\java\pictures\Snipaste_2023-12-28_21-54-56.png)

### 2.分布式锁

#### 1.特性

![](D:\学习笔记\java\pictures\Snipaste_2023-12-28_22-38-37.png)

#### 2.实现方式

1.最简化版本

比如setnx key value这个命令，key不存在设置为value，返回1，否则直接返回0。

第3步就没有获得到锁，设置失败

![](D:\学习笔记\java\pictures\Snipaste_2023-12-28_22-42-48.png)

2.支持过期时间

set key value nx ex expiretime

但是可能会有业务B释放业务A的锁的操作

3.加上owner

![](D:\学习笔记\java\pictures\Snipaste_2023-12-28_22-56-43.png)

执行完毕后，检查，释放；这些操作不是原子化

存在问题：锁在获取时是自己，删除时已经是别人的了（锁可能会过期）

4.引入Lua

![](D:\学习笔记\java\pictures\Snipaste_2023-12-28_23-07-04.png)

如果没有原子性，操作5后业务A发现锁归属还是自己，准备删锁，但此时锁过期，业务B获得了锁，业务A还是删除掉了锁，发生误删

#### 3.如何保证可靠性

主从容灾

Redis通过哨兵模式自主切换主从节点

![](D:\学习笔记\java\pictures\Snipaste_2023-12-28_23-24-55.png)

多机部署

![](D:\学习笔记\java\pictures\Snipaste_2023-12-28_23-38-27.png)

好处在于挂了几台Redis，整个集群还是可以用的，给了运维更多时间恢复。也可以为单个节点配置主从切换，这样单个节点数据的丢失就不会让锁失效。	

### 3.事务

开启事务：multi

后面的命令都会加进Redis队列中

执行：exec

放弃事务：discard

multi事务不具备原子性，只是利用单线程特性让其他操作切不进来。

#### Lua做事务

### 4.消息队列

#### list可做消息队列

blpop、brpop key time命令：阻塞式pop命令，没有消息就会阻塞，直到达到time时间。

#### Pub/Sub生产订阅

![](D:\学习笔记\java\pictures\Snipaste_2024-01-01_23-44-27.png)

订阅者订阅某个频道，消费者向这个频道发送消息，订阅者可以收到消息，支持多个订阅者订阅相同频道。

### 5.秒杀

Redis集群

1. **节点角色**：
   - **主节点（Master）**：负责处理写操作，并复制数据给从节点。
   - **从节点（Slave）**：负责处理读操作，从主节点复制数据。
2. **数据分片**：
   - Redis集群将数据分为16384个槽（0-16383），每个槽对应一个键。
   - 这些槽被分配给集群中的各个节点，每个节点负责管理一部分槽。

### 6.限流器

四种算法的比较