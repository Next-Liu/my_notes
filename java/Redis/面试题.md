#### 1.Set一个已有的数据

会替换掉原来的value

#### 2.浮点型String用什么表示

用EMBSTR或者RAW实现，浮点型长度小于阈值用EMBSTR

#### 3.String可以有多大

512MB

#### 4.Redis字符串是怎么实现的

如果存储的是整形，底层通过INT编码存储，如果存字符串，通过EMBSTR或者RAW编码存储。这两种编码有两部分RedisObject和SDS，RedisObject主要存储type和编码方式，SDS存储字符串的长度，分配空间以及字符串的内容。

#### 5.SDS的作用

可以在O(1)时间复杂度获取到字符串的长度，并且在为SDS分配存储空间的时候也会多分配空间，方便对字符串的添加。**不再以'\0'作为判断标准，二进制安全，可以存一些二进制数据**

#### 6.List是完全的先入先出吗

不是，Redis的List对象是双端队列，可以在队列两端进行添加和删除操作。

#### 7.List对象的底层编码方式

ziplist、linkedlist、quicklist（压缩链表组成的双向链表）

#### 8.ziplist是怎么压缩数据的

![](D:\学习笔记\java\pictures\Snipaste_2023-12-23_14-14-16.png)

所有数据存放在一个连续的空间中，每个元素小于64B，个数小于512个，ZIPLIST也可以实现list从后向前遍历，因为数据节点结构为

```java
<prevlen><encoding><entry-data>
prevlen：表示上一个结点的数据长度，可以定位上一个结点的起始地址，实现从后往前的操作 (记录结点总长度)：用当前节点地址减去这个长度
如果前一个结点长度>=254bytes,prevlen占5字节，否则占1字节
encoding：编码类型，还包含一个entry的长度信息，用于正向遍历(记录entry-data的长度)
```

查询节点个数的时间复杂度：O(1) zllen字段

#### 9.linkedlist查询节点个数的时间复杂度

O(1)，表头结构定义了链表包含的结点数

#### 10.Set是有序的吗？Set的编码方式

无序

intset：都是整数、数量不超过512，可以节约内存

hashtable：查询的时间复杂度为O(1)

#### 11.Hset的编码方式

ziplist

hashtable

hset查找某个key的平均复杂度：O(n)

#### 12.hashtable查找元素总数的平均复杂度

O(1)有size字段

#### 13.跳表中一个节点的高度

在最开始就确定，能否增加一层的概率为25%，5.0最大64层，7.0是32层

#### 14.redis是单线程的原因

多线程复杂，成本高，上下文切换，保存本地数据、程序指针等；一些公共资源为了保证同步需要加锁；一个线程本身也占用内存

#### 15.单线程的性能

#### 16.为什么单线程还可以这么快

1.内存数据库，对内存的操作速度本来就快 2.使用高效的数据结构存储对象，并且对象的底层数据结构也以节省内存，加快速度为主要思想而设计。3.多路复用机制，使其在网络IO操作可以并发处理大量客户端请求，实现高吞吐量

#### 17.Redis6.0后引入多线程的原因，是默认开启的吗

通过利用多个线程并行处理请求，可以更好地利用硬件资源，提高Redis在处理大量并发请求时的性能表现。不是默认开启

#### 18.引入多线程主要负责命令执行的哪一块？

#### 19.RDB和AOF的本质区别

1.RDB生成的是二进制文件，AOF生成的是文本文件

2.缓存宕机时，RDB会丢失更多的数据，AOF根据策略决定

3.RDB恢复速度更快

4.每一次RDB保存都是一次全量保存操作比较重，AOF是追加操作，操作比较轻。

#### 20.RDB和AOF怎么选

如果对数据要求高，不容忍数据丢失，可以同时使用AOF和RDB

如果可以接受分钟级别的数据丢失，使用RDB

#### 21.RDB和AOF的触发时机

RDB的触发时机在Redis配置文件中进行配置，使用的是后台式持久化

使用save和bgsave命令，save使用的是阻塞式持久化，bgsave使用的是后台式持久化

Redis正常关闭执行阻塞式持久化



AOF在Redis的配置文件中进行配置：applyonly字段no改为yes

#### 22.RDB对主流程的影响

使用阻塞式持久化的时候，由主进程进行RDB快照缓存，会阻塞主进程。

使用后台式持久化的时候，会通过fork出的子进程进行RDB快照缓存

​	如果数据量比较大，会导致fork子进程这个操作耗时，导致阻塞主进程

​	由于采用了写时复制，如果在RDB快照保存的时候有大量写入操作执行，会导致主进程多拷贝一份数据，占用大量额外的内存。

#### 23.AOF混合持久化方案

将内存数据写入到新的AOF文件中（数据格式是RDB格式）

重写期间新的写入命令使用追加的方式写入到AOF文件

#### 24.AOF重写流程

当AOF文件过大时，会触发重写，重写过程概括为一次拷贝，两次缓冲

一次拷贝：重写发生时，主进程会fork出一个子进程，让子进程将Redis数据写入到重写AOF文件

两处日志：重写发生时，有新的命令写入，会分别写入到AOF缓冲和AOF重写缓冲，AOF缓冲用于保证若此时宕机，原来的AOF文件完整，用于恢复，AOF重写缓冲用于保证新的AOF文件不会丢失数据。

#### 25.AOF重写有什么不足，怎么优化

需要额外的向AOF重写缓冲区写入数据，这部分数据与写入APF缓冲区的数据是重复的，占用内存。

子进程重写结束将重写缓冲区的数据写入到文件要消耗CPU时间



优化：MP-AOF

#### 26.你有实际使用过Redis做过什么应用吗

做旁路缓存

#### 27.Redis缓存是如何应用的

用作旁路缓存，先查Redis，如果没有再查数据库并将数据写到Redis

#### 28.Redis做旁路缓存，如果MySQL更新，此时何去何从。

先删除Redis缓存，后面再读数据时通过MySQL更新Redis

#### 29.Redis作秒杀的思路

#### 30.Redis作消息队列

## ***Redis如何做分布式锁**

#### 31.分布式锁的要点

加锁的时候要设置owner和过期时间，owner用来确定锁的拥有者，过期时间用来兜底应对异常情况

解锁的时候要先判断owner是不是自己的，是自己的再释放。这两部操作要保证原子性。

## *Zset的底层结构



#### 32.缓存异常

缓存穿透：指访问的key缓存和数据库都没有，但用户一直发出请求，导致请求都去查询数据库，使得数据库压力过大宕机。

缓存击穿：一般指某个热点数据在缓存中没有，数据库有，突然查询量过大使得数据库压力骤增

缓存雪崩：某一时间内大批量数据过期，此时大量请求查询数据库导致数据库压力过大



