####  1.Set一个已有的数据

会替换掉原来的value

#### 2.浮点型String用什么表示

用EMBSTR或者RAW实现，浮点型长度小于阈值用EMBSTR

#### 3.String可以有多大

512MB

#### 4.Redis字符串是怎么实现的

如果存储的是整形，底层通过INT编码存储，如果存字符串，通过EMBSTR或者RAW编码存储。这两种编码有两部分RedisObject和SDS，RedisObject主要存储type和编码方式，SDS存储字符串的长度，分配空间以及字符串的内容。

#### 5.SDS的作用

可以在O(1)时间复杂度获取到字符串的长度，并且在为SDS分配存储空间的时候也会多分配空间，方便对字符串的添加。**不再以'\0'作为判断标准，而是以len长度判断，二进制安全（因为一些二进制文件，如图片、视频可能包括空字符），可以存一些二进制数据**

#### 6.List是完全的先入先出吗

不是，Redis的List对象是双端队列，可以在队列两端进行添加和删除操作。

#### 7.List对象的底层编码方式

ziplist、linkedlist、quicklist（压缩链表组成的双向链表）

#### 8.ziplist是怎么压缩数据的

![](D:\学习笔记\java\pictures\Snipaste_2023-12-23_14-14-16.png)

所有数据存放在一个连续的空间中，每个元素小于64B，个数小于512个，ZIPLIST也可以实现list从后向前遍历，因为数据节点结构为

```java
<prevlen><encoding><entry-data>
prevlen：表示上一个结点的数据长度，可以定位上一个结点的起始地址，实现从后往前的操作 (记录结点总长度)：用当前节点地址减去这个长度
如果前一个结点长度>=254bytes,prevlen占5字节，否则占1字节
encoding：编码类型，还包含一个entry的长度信息，用于正向遍历(记录entry-data的长度)
```

查询节点个数的时间复杂度：O(1) zllen字段

#### 9.linkedlist查询节点个数的时间复杂度

O(1)，表头结构定义了链表包含的结点数

#### 10.Set是有序的吗？Set的编码方式

无序

intset：都是整数、数量不超过512，可以节约内存

hashtable：查询的时间复杂度为O(1)

#### 11.Hset的编码方式

ziplist

hashtable

hset查找某个key的平均复杂度：O(n)

#### 12.hashtable查找元素总数的平均复杂度

O(1)有size字段

#### 13.跳表中一个节点的高度

在最开始就确定，能否增加一层的概率为25%，5.0最大64层，7.0是32层

#### 14.redis是单线程的原因

多线程复杂，成本高，上下文切换，保存本地数据、程序指针等；一些公共资源为了保证同步需要加锁；一个线程本身也占用内存

#### 15.单线程的性能

#### 16.为什么单线程还可以这么快

1.内存数据库，对内存的操作速度本来就快 2.使用高效的数据结构存储对象，并且对象的底层数据结构也以节省内存，加快速度为主要思想而设计。3.多路复用机制监听多个socket，这样可以**让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗**

#### 17.Redis6.0后引入多线程的原因，是默认开启的吗

通过利用多个线程并行处理请求，可以更好地利用硬件资源，提高Redis在处理大量并发请求时的性能表现。不是默认开启

#### 18.引入多线程主要负责命令执行的哪一块？

#### 19.RDB和AOF的本质区别

1.RDB生成的是二进制文件，AOF生成的是文本文件

2.缓存宕机时，RDB会丢失更多的数据，AOF根据策略决定

3.RDB恢复速度更快

4.每一次RDB保存都是一次全量保存操作比较重，AOF是追加操作，操作比较轻。

#### 20.RDB和AOF怎么选

如果对数据要求高，不容忍数据丢失，可以同时使用AOF和RDB

如果可以接受分钟级别的数据丢失，使用RDB

#### 21.RDB和AOF的触发时机

RDB的触发时机在Redis配置文件中进行配置，使用的是后台式持久化

使用save和bgsave命令，save使用的是阻塞式持久化，bgsave使用的是后台式持久化

Redis正常关闭执行阻塞式持久化



AOF在Redis的配置文件中进行配置：applyonly字段no改为yes

#### 22.RDB对主流程的影响

使用阻塞式持久化的时候，由主进程进行RDB快照缓存，会阻塞主进程。

使用后台式持久化的时候，会通过fork出的子进程进行RDB快照缓存

​	如果数据量比较大，会导致fork子进程这个操作耗时，导致阻塞主进程

​	由于采用了写时复制，如果在RDB快照保存的时候有大量写入操作执行，会导致主进程多拷贝一份数据，占用大量额外的内存。

#### 23.AOF混合持久化方案

将内存数据写入到新的AOF文件中（数据格式是RDB格式）

重写期间新的写入命令使用追加的方式写入到AOF文件

#### 24.AOF重写流程

当AOF文件过大时，会触发重写，重写过程概括为一次拷贝，两次缓冲

一次拷贝：重写发生时，主进程会fork出一个子进程，让子进程将Redis数据写入到重写AOF文件

两处日志：重写发生时，有新的命令写入，会分别写入到AOF缓冲和AOF重写缓冲，AOF缓冲用于保证若此时宕机，原来的AOF文件完整，用于恢复，AOF重写缓冲用于保证新的AOF文件不会丢失数据。

#### 25.AOF重写有什么不足，怎么优化

需要额外的向AOF重写缓冲区写入数据，这部分数据与写入APF缓冲区的数据是重复的，占用内存。

子进程重写结束将重写缓冲区的数据写入到文件要消耗CPU时间



优化：MP-AOF

#### 26.你有实际使用过Redis做过什么应用吗

做旁路缓存

#### 27.Redis缓存是如何应用的

用作旁路缓存，先查Redis，如果没有再查数据库并将数据写到Redis

#### 28.Redis做旁路缓存，如果MySQL更新，此时何去何从。

先删除Redis缓存，后面再读数据时通过MySQL更新Redis

#### 29.Redis作秒杀的思路

#### 30.Redis作消息队列

## ***Redis如何做分布式锁**

#### 31.分布式锁的要点

加锁的时候要设置owner和过期时间，owner用来确定锁的拥有者，过期时间用来兜底应对异常情况

解锁的时候要先判断owner是不是自己的，是自己的再释放。这两部操作要保证原子性。

## *Zset的底层结构

**1.ziplist**

保存的所有字符串长度小于64B

保存个数小于128个

**2.跳跃表（Skip List） 和 哈希表（Hash Table）。**

任一条件不满足用skipList和hash

- **元素唯一**：每个元素都是唯一的，类似于 Set。
- **有序性**：元素按照分数（score）排序，类似于有序列表。

跳表：

​	每层链表均有序

hash表：

​	哈希表用于存储元素和分数的映射关系。

![](D:\学习笔记\java\pictures\Snipaste_2025-03-11_01-48-27.png)

#### 32.缓存异常

**缓存穿透：**指访问的key缓存和数据库都没有，但用户一直发出请求，导致请求都去查询数据库，使得数据库压力过大宕机。

​	**解决方法：**

​		缓存无效key

​		布隆过滤器：迅速判断一个key是否在缓存中，使用一个较大的 bit 数组来保存所有的数据，数组中的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1（代表 false 或者 true）：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。

**缓存击穿：**一般指某个热点数据在缓存中没有，数据库有，突然查询量过大使得数据库压力骤增

​	**解决方法：**

​		**提前预热**（推荐）：针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。

​		**加锁**（看情况）：在缓存失效后，通过设置互斥锁确保只有一个请求去查询数据库并更新缓存

**缓存雪崩：**某一时间内大批量数据过期，此时大量请求查询数据库导致数据库压力过大

#### 33.延迟双删

**延迟双删**（Delay Double Delete）是一种在数据更新或删除时为了保证[数据一致性](https://so.csdn.net/so/search?q=数据一致性&spm=1001.2101.3001.7020)而采取的策略。这种策略通常用于解决数据在缓存和数据库中不一致的问题。

**更新缓存模式**：每次更新数据库都更新缓存，无效写操作较多

**删除缓存模式**：更新数据时更新数据库并删除缓存，查询时更新缓存，无效写操作较少，那么是先操作缓存还是先操作数据库？

​	如何操作呢？

​	**先操作缓存**：先删缓存，再更新数据库。请求直接到数据库，给数据库带来巨大压力

​	**先操作数据库**：先更新数据库，再删缓存。当线程1在查询缓存且未命中，此时线程1查询数据，查询完准备写入缓存时，由于没有加锁线程2乘虚而入，线程2在这期间对数据库进行了更新，此时线程1将旧数据返回了，出现了脏读，但是这种概率很小

#### 如果就想先操作缓存，再更新数据库怎么办？

延迟双删：当需要更新数据库中的数据时，首先会先删除缓存，然后再进行数据库的更新操作。这样做的目的是**为了避免在数据库更新的过程中，有其他请求读取了已经失效的缓存数据。**

1. **第一次删除**：在更新数据库之前，先删除缓存。（因为数据库需要更新，在更新数据库之前，先删除缓存，确保后续读取操作不会命中旧数据。）
2. **更新数据库**：执行数据库更新操作。
3. **第二次删除**：在数据库更新完成后，延迟一段时间再次删除缓存。（为了防止在数据库更新过程中，其他线程读取到旧数据并重新写入缓存。）

**更新缓存的问题：**

- **场景**：多个线程同时更新数据库和缓存时，可能由于执行顺序问题导致缓存与数据库不一致。

  示例：

  1. **线程 A** 更新数据库 `set stock = 90`。
  2. **线程 B** 更新数据库 `set stock = 80`。
  3. **线程 B** 先更新缓存 `Redis.set("stock", 80)`。
  4. **线程 A** 后更新缓存 `Redis.set("stock", 90)`。

- **结果**：数据库最终值是 `80`，但缓存是 `90`（脏数据）。

#### 34.Redis过期删除和内存淘汰

#####  1.**定期删除**

- **原理**：Redis 默认每隔 100ms 随机抽取一部分设置了过期时间的键，检查是否过期，如果过期则删除。
- **优点**：减少对 CPU 的占用，避免频繁检查所有键。
- **缺点**：可能导致部分过期键未被及时删除，占用内存。

##### **2.惰性删除**

- ##### **原理**：当客户端访问某个键时，Redis 会检查该键是否过期，如果过期则删除。

- **优点**：确保访问到的键一定是有效的。

- **缺点**：如果**过期键未被访问，可能会一直占用内存。**

**3.定时删除**

每个设置了过期时间的 key 都会在设置的时间到达时立即被删除。这种方法可以确保内存中不会有过期的键，但是它对 CPU 的压力最大，因为它需要为每个键都设置一个**定时器**。

#### 34.1 内存淘汰策略

1. noeviction

   （默认策略）：

   - 不删除任何数据，当内存不足时，新写入操作会报错。
   - 适用于数据不可丢失的场景。

2. allkeys-lru

   - 从所有键中删除最近最少使用（LRU）的键。
   - 适用于需要保留热点数据的场景。

3. volatile-lru

   - 从设置了过期时间的键中删除最近最少使用（LRU）的键。
   - 适用于需要保留未过期数据的场景。

4. allkeys-random

   - 从所有键中随机删除键。
   - 适用于对数据删除无特殊要求的场景。

5. volatile-random

   - 从设置了过期时间的键中随机删除键。
   - 适用于对未过期数据无特殊要求的场景。

6. volatile-ttl

   - 从设置了过期时间的键中删除剩余生存时间（TTL）最短的键。
   - 适用于优先删除即将过期数据的场景。

#### 35.Redis的缓存一致性如何保证

Cache Aside Pattern 中遇到写请求是这样的：更新数据库，然后直接删除缓存。

如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说有两个解决方案：

1. **缓存失效时间变短**（不推荐，治标不治本）：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。
2. **增加缓存更新重试机制**（常用）：如果缓存服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。不过，这里更适合引入消息队列实现异步重试，将删除缓存重试的消息投递到消息队列，然后由专门的消费者来重试，直到成功。虽然说多引入了一个消息队列，但其整体带来的收益还是要更高一些。

#### 36.Redis如何保证高可用

##### **1. 主从复制（Replication）**

- 通过主从复制，可以将主节点的数据同步到多个从节点。
- 当主节点发生故障时，可以将从节点提升为新的主节点，继续提供服务。
  - 数据冗余：从节点可以备份主节点的数据。
  - 读写分离：可以将读请求分发到从节点，减轻主节点的压力。
  - 主节点故障时，需要手动或通过工具将从节点提升为主节点。

##### **2. 哨兵模式（Sentinel）**

- 哨兵模式是 Redis 官方提供的高可用解决方案。
- 哨兵节点监控主节点和从节点的状态，当主节点发生故障时，自动将一个从节点提升为新的主节点。
  - 自动故障转移：主节点故障时，哨兵会自动将从节点提升为主节点。
  - 高可用性：多个哨兵节点可以组成集群，避免单点故障。

##### **3. Redis 集群（Cluster）**

- Redis 集群是 Redis 官方提供的分布式解决方案。
- 通过分片（Sharding）将数据分布到多个节点上，支持自动故障转移和数据迁移。

##### 4.持久化机制